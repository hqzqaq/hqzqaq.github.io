<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>java redis |  hqz的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-java-redis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  java redis
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/23/java-redis/" class="article-date">
  <time datetime="2022-09-23T05:56:18.000Z" itemprop="datePublished">2022-09-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">17 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p><font style="color:#52beee;font-size:50px">Redis</font></p>
<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL &#x3D; Not Only SQL （不仅仅是 SQL）</p>
<p>关系型数据库：表格、行、列</p>
<p>NoSQL 泛指 非关系型数据库，随着 web 2.0 互联网的诞生，传统的关系型数据库很难对付 web 2.0 时代，尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL 在当今的大数据环境下发展的十分迅速，Redis 是发展最快的。</p>
<span id="more"></span>

<h2 id="1、NoSQL-特点"><a href="#1、NoSQL-特点" class="headerlink" title="1、NoSQL 特点"></a>1、NoSQL 特点</h2><ol>
<li>方便扩展（数据间没有关系，很好扩展）</li>
<li>大数据量性能高（Redis 一秒写 8 万次，读取 11 万次，NoSQL 的缓存记录级，是一种细粒度的缓存，性能比较高）</li>
<li>数据类型是多样的（不需要事先设计数据库，随取随用）</li>
</ol>
<h2 id="2、RDBMS-和-NoSQL"><a href="#2、RDBMS-和-NoSQL" class="headerlink" title="2、RDBMS 和 NoSQL"></a>2、RDBMS 和 NoSQL</h2><table>
<thead>
<tr>
<th>传统 RDBMS</th>
<th>NoSQL</th>
</tr>
</thead>
<tbody><tr>
<td>结构化组织</td>
<td>不仅仅是数据</td>
</tr>
<tr>
<td>SQL</td>
<td>没有固定的查询语言</td>
</tr>
<tr>
<td>数据和关系都存在单独的表中</td>
<td>键值对存储，列存储，文档存储，图形数据库（社交关系）</td>
</tr>
<tr>
<td>数据操作语言，数据定义语言</td>
<td>最终一致性</td>
</tr>
<tr>
<td>基础的事务</td>
<td>CPA 定理 和 BASE （异地多活）</td>
</tr>
<tr>
<td></td>
<td>高性能、高可用、高可扩</td>
</tr>
</tbody></table>
<h2 id="3、3-V-和-3-高"><a href="#3、3-V-和-3-高" class="headerlink" title="3、3 V 和 3 高"></a>3、3 V 和 3 高</h2><p>大数据时代的 3V ：主要是描述问题的</p>
<ol>
<li>海量 <code>Volume</code></li>
<li>多样 <code>Variety</code></li>
<li>实时 <code>Velocity</code></li>
</ol>
<p>大数据时代的 3 高：主要是对程序的要求</p>
<ol>
<li>高并发</li>
<li>高可扩</li>
<li>高性能</li>
</ol>
<h2 id="4、NoSQL-的四大分类"><a href="#4、NoSQL-的四大分类" class="headerlink" title="4、NoSQL 的四大分类"></a>4、NoSQL 的四大分类</h2><h3 id="4-1、K-V-键值对："><a href="#4-1、K-V-键值对：" class="headerlink" title="4.1、K - V 键值对："></a>4.1、K - V 键值对：</h3><ul>
<li>新浪：Redis</li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Redis + memecache</li>
</ul>
<h3 id="4-2、文档型数据（bson-格式-和-json-一样）"><a href="#4-2、文档型数据（bson-格式-和-json-一样）" class="headerlink" title="4.2、文档型数据（bson 格式 和 json 一样）"></a>4.2、文档型数据（bson 格式 和 json 一样）</h3><ul>
<li>MongoDB<ul>
<li>MongoDB 是一个基于分布式文件存储的数据库，由 c++ 编写，主要用来处理大量的文档</li>
<li>MongoDB 是一个介于关系型数据库和非关系型数据库中间的产品，MongoDB 是非关系型数据库中功能最丰富，最像关系型数据库的</li>
</ul>
</li>
<li>ConthDB</li>
</ul>
<h3 id="4-3、列存储数据库"><a href="#4-3、列存储数据库" class="headerlink" title="4.3、列存储数据库"></a>4.3、列存储数据库</h3><ul>
<li>HBase</li>
<li>分布式文件系统</li>
</ul>
<h3 id="4-4、图关系数据库"><a href="#4-4、图关系数据库" class="headerlink" title="4.4、图关系数据库"></a>4.4、图关系数据库</h3><ul>
<li>存的是关系，比如：朋友圈社交网络，广告推荐</li>
<li>Neo4j、InfoGrid</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>Examples举例</th>
<th>典型应用场景</th>
<th>数据模型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>键值（key-value）</td>
<td>Tokyo Cabinet&#x2F;Tyrant，<br>Redis，Voldemort，Oracle BDB</td>
<td>内容缓存，主要用于处理<br>大量数据的高访问负载，也用<br>于一些日志系统等等</td>
<td>key 指向 value的<br>键值对，通常用 hash table 来实现</td>
<td>查找速度快</td>
<td>数据无结构化，通常<br>只被当作字符串或者二进制数据</td>
</tr>
<tr>
<td>列存储数据库</td>
<td>Cassandra，HBase，<br>Riak</td>
<td>分布式的文件系统</td>
<td>以列簇式存储，<br>将同一列数据存在一起</td>
<td>查找速度快，可扩展性强，<br>更容易进行分布式扩展</td>
<td>功能相对局限</td>
</tr>
<tr>
<td>文档型数据库</td>
<td>CouchDB，MongoDB</td>
<td>Web 应用（与 key - value 类似，value 是结构化的，<br>不同的是数据库能够了解 value 的内容</td>
<td>key - value 对应的键值对，<br>value 为结构化数据</td>
<td>数据结构要求不严格，表结构可变，<br>不需要像关系型数据库一样需要预先定义表结构</td>
<td>查询性能不高，而且<br>缺乏统一的查询语法</td>
</tr>
<tr>
<td>图形（Graph）数据库</td>
<td>Neo4J，InfoGrid，<br>Infinite Graph</td>
<td>社交网络，推荐系统等。<br>专注于构建关系图谱</td>
<td>图结构</td>
<td>利用图结构相关算法。<br>比如最短路径寻址，N度<br>关系查找</td>
<td>很多时候需要对整个图<br>做计算才能得出需要的信息，<br>而且这种结构不太好做分布式的集群方案</td>
</tr>
</tbody></table>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="5、概述"><a href="#5、概述" class="headerlink" title="5、概述"></a>5、概述</h2><blockquote>
<p>redis 是什么？</p>
</blockquote>
<p><code>Redis（Remote Dictionary Server）</code>，即远程字典服务</p>
<p>是一个开源的使用 ANSI c语言 编写、支持网络、可基于内存亦可持久化的日志型、key - value 数据库，并提供多种语言的 api</p>
<blockquote>
<p>redis 能干嘛 ?</p>
</blockquote>
<ol>
<li>内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器</li>
</ol>
<p>……</p>
<blockquote>
<p>特性</p>
</blockquote>
<ol>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
</ol>
<p>……</p>
<h2 id="6、基础的知识"><a href="#6、基础的知识" class="headerlink" title="6、基础的知识"></a>6、基础的知识</h2><p>redis 默认有 16 个数据库，默认使用第一个数据库</p>
<blockquote>
<p>redis 是单线程的</p>
</blockquote>
<p>redis 是基于内存操作，cpu 不是 redis 的性能瓶颈，redis 的瓶颈是根据机器的内存和网络带宽来决定的</p>
<blockquote>
<p>redis 为什么这么快？</p>
</blockquote>
<p>redis 是将所有数据全部存放到内存中的，所以说使用单线程去操作效率就是最高的，多线程（cpu 上下文切换是耗时的操作），对于内存系统来说，没有上下文切换效率就是最高的。</p>
<h2 id="7、基础命令"><a href="#7、基础命令" class="headerlink" title="7、基础命令"></a>7、基础命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据库所有的键</span></span><br><span class="line">keys * </span><br><span class="line"><span class="comment"># 获取键值</span></span><br><span class="line">get [key]</span><br><span class="line"><span class="comment"># 设置键值</span></span><br><span class="line"><span class="built_in">set</span> [key] [value]</span><br><span class="line"><span class="comment"># 清除当前数据库</span></span><br><span class="line">flushdb</span><br><span class="line"><span class="comment"># 清除全部数据库内容 </span></span><br><span class="line">flushall</span><br><span class="line"><span class="comment"># 是否存在某个键 </span></span><br><span class="line">exists [key]</span><br><span class="line"> <span class="comment"># 移除键值</span></span><br><span class="line"> move [key] [value]</span><br><span class="line"> <span class="comment"># 设置过期时间</span></span><br><span class="line"> expire [key] [time]</span><br><span class="line"> <span class="comment"># 查看键值的数据类型</span></span><br><span class="line"> <span class="built_in">type</span> [key]</span><br><span class="line"> <span class="comment"># 追加字符串，如果当前 key 不存在相当于 setkey</span></span><br><span class="line"> append [key] [appendStr]</span><br><span class="line"> <span class="comment"># 查看字符串的长度</span></span><br><span class="line"> strlen [key]</span><br><span class="line"> <span class="comment"># 自增 1</span></span><br><span class="line"> incr [key]</span><br><span class="line"> <span class="comment"># 自减 1</span></span><br><span class="line"> decr [key]</span><br><span class="line"> <span class="comment"># 自增步长</span></span><br><span class="line"> incrby [key] [number] </span><br></pre></td></tr></table></figure>



<h2 id="8、基本数据类型"><a href="#8、基本数据类型" class="headerlink" title="8、基本数据类型"></a>8、基本数据类型</h2><h3 id="8-1、String"><a href="#8-1、String" class="headerlink" title="8.1、String"></a>8.1、String</h3><ul>
<li>计数器</li>
<li>统计多单位的数量</li>
<li>粉丝数</li>
<li>对象缓存存储</li>
</ul>
<h3 id="8-2、List"><a href="#8-2、List" class="headerlink" title="8.2、List"></a>8.2、List</h3><p>redis 可以将 list 实现为 栈、队列、阻塞队列</p>
<p>所有的 list 命令都是以 l 开头的</p>
<p>左右两边都可以插入数据 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左右插入数据</span></span><br><span class="line">lpush、rpush</span><br><span class="line"><span class="comment"># 移除元素</span></span><br><span class="line">lpop、rpop</span><br><span class="line"><span class="comment"># 根据下标获取元素</span></span><br><span class="line">lindex、rindex</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>它实际上是一个链表，before、node、after、left、right 都可以插入值</li>
<li>如果 key 不存在，创建新的链表</li>
<li>如果 key 存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高，中间元素，相对来说效率会低一点</li>
</ul>
<p>消息排队，消息队列（lpush、rpop）、栈（lpush、lpop）</p>
<h3 id="8-3、Set"><a href="#8-3、Set" class="headerlink" title="8.3、Set"></a>8.3、Set</h3><p>set 开头都是 s</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加值</span></span><br><span class="line">sadd</span><br><span class="line"><span class="comment"># 查看指定 set 所有值</span></span><br><span class="line">smembers</span><br><span class="line"><span class="comment"># 判断一个值是否在 set 集合中</span></span><br><span class="line">sismember</span><br><span class="line"><span class="comment"># 获取集合元素个数</span></span><br><span class="line">scard</span><br><span class="line"><span class="comment"># 移除 set 集合中的指定元素</span></span><br><span class="line">srem</span><br><span class="line"><span class="comment"># 随机抽出指定元素</span></span><br><span class="line">srandmember</span><br><span class="line"><span class="comment"># 差集</span></span><br><span class="line">sdiff</span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">sinter</span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line">sunion</span><br></pre></td></tr></table></figure>



<h3 id="8-4、Hash"><a href="#8-4、Hash" class="headerlink" title="8.4、Hash"></a>8.4、Hash</h3><p>map 集合 key - map</p>
<p>命令以 h 开头</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加值</span></span><br><span class="line">hset</span><br><span class="line">hget</span><br><span class="line"><span class="comment"># 存在即覆盖，不存在则创建</span></span><br><span class="line">hmset</span><br><span class="line"><span class="comment"># 获取多个值</span></span><br><span class="line">hmget</span><br></pre></td></tr></table></figure>



<p>hash 变更的数据 user name age 尤其是用户信息之类的，经常变动的信息，hash 更适合于对象的存储、string 类型更适合字符串存储</p>
<h3 id="8-5、Zset（有序集合）"><a href="#8-5、Zset（有序集合）" class="headerlink" title="8.5、Zset（有序集合）"></a>8.5、Zset（有序集合）</h3><p>在 set 的基础上，增加了一个值，zset k1 score1 v1</p>
<p>set 排序 存储班级成绩表 工资表排序</p>
<p>普通消息，1，重要消息 2，带权重进行判断</p>
<p>排行榜应用实现，取 top N 测试</p>
<h2 id="9、三大特殊的数据类型"><a href="#9、三大特殊的数据类型" class="headerlink" title="9、三大特殊的数据类型"></a>9、三大特殊的数据类型</h2><h3 id="9-1、geospatial-地理位置"><a href="#9-1、geospatial-地理位置" class="headerlink" title="9.1、geospatial 地理位置"></a>9.1、geospatial 地理位置</h3><p>朋友的定位、附近的人，打车距离计算，这个功能可以推算出地理位置的信息，两地之间的距离、方圆几里的人</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加地理位置</span></span><br><span class="line">geoadd [key] [lat] [lng] [locarion_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取地理位置</span></span><br><span class="line">geopos [key] [location_name] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># geodist 返回两人之间的距离</span></span><br><span class="line"><span class="comment"># 单位：</span></span><br><span class="line"><span class="comment"># m 米</span></span><br><span class="line"><span class="comment"># km 千米</span></span><br><span class="line"><span class="comment"># mi 英里</span></span><br><span class="line"><span class="comment"># ft 英尺</span></span><br><span class="line"></span><br><span class="line">geodist [key] [location_name1] [location_name2] [unit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以给定的经纬度为中心，找出某一半径内的元素</span></span><br><span class="line">georadius [key] [lat] [lng] [radius] [unit] withdist [显示到中间距离的位置] withcoord [显示他人的定位信息] count [筛选出指定的结果]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以成员为中心，找出某一半径内的元素</span></span><br><span class="line">georadiusbymember [key] [location_name] [radius] [unit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个或多个位置元素的 geohash 表示，返回 11 个字符的 geohash 字符串</span></span><br><span class="line">geohash</span><br><span class="line"></span><br><span class="line"><span class="comment"># geo 的底层实现原理是 zset，可以使用 zset 命令操作 geo</span></span><br></pre></td></tr></table></figure>



<h3 id="9-2、Hyperloglog"><a href="#9-2、Hyperloglog" class="headerlink" title="9.2、Hyperloglog"></a>9.2、Hyperloglog</h3><blockquote>
<p>什么是基数？</p>
</blockquote>
<p>基数（不重复的元素），可以接受误差。</p>
<p>redis hyperloglog 基数统计的方法</p>
<p>优点：占用的内存是固定的，2^64不同的元素的技术，只需要12 kb</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>网页的 UV （一个人访问一个网站多次，但是还是算为一个人）</p>
<p>传统的方式：set集合 保存用户 id</p>
<p>这种方式保存大量的用户的 id 会比较麻烦，目的是为了计数不是为了保存用户 id</p>
<p>redis hyperloglog：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PFadd key1 a b c d</span><br><span class="line"></span><br><span class="line">PFCOUNT key1</span><br><span class="line"></span><br><span class="line">PFadd key2 a b c d e</span><br><span class="line"></span><br><span class="line">PFMERGE key3 key1 key2</span><br></pre></td></tr></table></figure>





<h3 id="9-3、Bitmaps"><a href="#9-3、Bitmaps" class="headerlink" title="9.3、Bitmaps"></a>9.3、Bitmaps</h3><blockquote>
<p>位存储</p>
</blockquote>
<p>两个状态的都可以使用 bitmaps</p>
<p>Bitmaps 位图，数据结构都是操作二进制位来进行记录，就只有 0 和 1 两个状态</p>
<p>使用 bitmapp 来记录 周一到周日的打卡</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setbit sign 0 1</span><br><span class="line">......</span><br><span class="line">setbit sign 6 0</span><br></pre></td></tr></table></figure>

<p>查看某一天是否有打卡</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getbit sign 0</span><br><span class="line">getbit sign 6</span><br><span class="line">bitcount sign # 统计所有打开的天数</span><br></pre></td></tr></table></figure>





<h2 id="10、事务"><a href="#10、事务" class="headerlink" title="10、事务"></a>10、事务</h2><p>redis 单条命令是保证原子性的，但是事务是不保证原子性的</p>
<blockquote>
<p>redis 事务的本质：一组命令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行。</p>
<p>一次性、顺序性、排他性</p>
</blockquote>
<p><font color="orange">redis 事务没有隔离级别的概念</font></p>
<p>所有的命令在事务中并没有直接被执行，只有发起执行命令的时候才会执行</p>
<p>redis 事务：</p>
<ul>
<li>开启事务</li>
<li>执行事务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multi # 开启事务</span><br><span class="line">set k1 k2</span><br><span class="line">....</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">期间执行的命令都将入队</span></span><br><span class="line">exec # 执行事务,将按顺序执行队列里的所有命令</span><br><span class="line">DISCARD # 取消事务</span><br></pre></td></tr></table></figure>



<ul>
<li>编译型异常(代码有问题或命令有问题),事务中的所有命令都不会被执行</li>
<li>运行时异常(1&#x2F;0),如果事务队列中存在语法错误,那么执行命令的时候,其它命令是可以正常执行的,错误命令抛出异常</li>
</ul>
<blockquote>
<p>悲观锁</p>
</blockquote>
<blockquote>
<p>乐观锁</p>
</blockquote>
<p>使用 watch 可以当作 redis 的乐观锁操作,如果事务执行失败,用 unwatch 解锁</p>
<h1 id="redis-进阶"><a href="#redis-进阶" class="headerlink" title="redis 进阶"></a>redis 进阶</h1><h2 id="11、redis-conf"><a href="#11、redis-conf" class="headerlink" title="11、redis conf"></a>11、redis conf</h2><blockquote>
<p>网络</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 # 绑定的ip</span><br><span class="line">protecte-mode yes # 保护模式</span><br><span class="line">port 6379 # 端口设置</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通用 GENERAL</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes # 以守护进程的方式打开，默认是 no，需要自己开启</span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6379.pid # 如果以后台的方式运行需要指定一个 pid 文件</span><br><span class="line"></span><br><span class="line">loglevel notice # debug verbose notice warning 日志级别</span><br><span class="line"></span><br><span class="line">logfile &quot;&quot; # 日志文件的位置</span><br><span class="line">databases 16 # 数据库的数量</span><br><span class="line">always-show-logo no # 是否总是显示 logo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>快照</p>
</blockquote>
<p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof </p>
<p>redis 是内存数据库，如果没有持久化，那么数据断电就会消失</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 3600s 内进行了至少一次 key 操作，则进行持久化操作</span></span><br><span class="line">save 3600 1</span><br><span class="line">save 300 100</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">持久化出错，是否还需要继续工作</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否压缩 rdb 文件，需要消耗一些 cpu 资源</span></span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes # 保存 rdb 文件的时候，进行错误的检查校验</span><br><span class="line"></span><br><span class="line">dir ./ # rdb 文件保存的目录</span><br></pre></td></tr></table></figure>



<blockquote>
<p>replication 主从复制</p>
</blockquote>
<blockquote>
<p>security</p>
</blockquote>
<p>设置 redis 密码，默认是没有密码的</p>
<blockquote>
<p>client</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000</span><br><span class="line">maxmemory &lt;bytes&gt;</span><br><span class="line">maxmemory-policy noeviction # 内存到达上限的处理策略</span><br></pre></td></tr></table></figure>

<blockquote>
<p>APPEND ONLY MODE aof 配置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly no # 默认不开启，默认使用 rdb 方式持久化</span><br></pre></td></tr></table></figure>

<h2 id="12、redis-持久化"><a href="#12、redis-持久化" class="headerlink" title="12、redis 持久化"></a>12、redis 持久化</h2><p>指定的时间间隔内，将内存中的数据集快照写入磁盘。恢复时是将快照文件直接读到内存里</p>
<p>redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何 IO 操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感的，那 RDB 方式要比 AOF 方式更加的高效。<font color="orange">RDB 的缺点是最后一次持久化后的数据可能丢失</font>。</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li>save 的规则满足的情况下，会自动触发 rdb 规则</li>
<li>执行 flushall 命令，也会触发 rdb 规则</li>
<li>退出 redis ，也会产生 rdb 文件</li>
</ol>
<blockquote>
<p>恢复数据</p>
</blockquote>
<p>将 rdb 文件 放在 redis 的启动目录即可（&#x2F;usr&#x2F;local&#x2F;bin）</p>
<p><strong>优点：</strong></p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>需要一定的时间间隔进行操作，如果 redis 意外宕机了，这个最后一次修改的数据就没有了</li>
<li>fork 进程的时候会占用一点的内存空间</li>
</ol>
<h2 id="13、redis-发布订阅"><a href="#13、redis-发布订阅" class="headerlink" title="13、redis 发布订阅"></a>13、redis 发布订阅</h2><p>redi 发布订阅（pub&#x2F;sub）是一种<font color="orange">消息通信模式</font>：发送者（pub）发送消息，订阅者（sub）接收消息</p>
<p>redis 客户端可以订阅任意数量的频道</p>
<p>第一个：消息发送者，第二个：频道，第三个：消息订阅者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">订阅一个或多个符合给定模式的频道</span></span><br><span class="line">PSUBSCRIBE pattern</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看订阅与发布系统状态</span></span><br><span class="line">PUBSUB subcommand [argument ]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将消息发送到指定的频道</span></span><br><span class="line">PUBLISH channel message</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退订所有给定模式的频道</span></span><br><span class="line">PUNSUBSCRIBE [pattern]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">订阅给定的一个或多个频道的消息</span></span><br><span class="line">SUBSCRIBE channel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退订指定的频道</span></span><br><span class="line">UNSUBSCRIBE [channel]</span><br></pre></td></tr></table></figure>

<h2 id="14、redis-主从复制"><a href="#14、redis-主从复制" class="headerlink" title="14、redis 主从复制"></a>14、redis 主从复制</h2><p>主从复制，是指将一台 Redis 服务器的数据复制到其它的 redis 服务器。前者称为主节点（master&#x2F;leader），后者称为从节点（slave&#x2F;follower）数据的复制是单向的，只能由主节点到从节点。Master 以写为主，Slave 以读为主。</p>
<p>默认情况下，每台 redis 服务器都是主节点，且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p>
<p>主从复制的作用主要包括：</p>
<ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 redis 数据时应用连接主节点，读 redis 数据时应用连接从节点），分担服务器负载，尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 redis 服务器的并发量</li>
<li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制时 redis 高可用的基础</li>
</ol>
<blockquote>
<p>环境配置</p>
</blockquote>
<p>只配置从库，不用配置主库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看角色</span></span><br><span class="line">info replication</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从机配置主库</span></span><br><span class="line">SLAVEOF [ip] [port]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复制原理</p>
</blockquote>
<p>slave 启动成功连接到 master 后会发送一个 sync 同步命令</p>
<p>master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave，并完成一次完全同步</p>
<p><code>全量复制</code>：slave 服务在接收到数据库文件数据之后，将其存盘并加载到内存中</p>
<p><code>增量复制</code>：master 继续将新的所有收集到的修改命令依次传给 slave ，完成同步</p>
<p>只要是重新连接 master，一次完成同步（全量复制）将被自动执行</p>
<blockquote>
<p>哨兵模式</p>
</blockquote>
<p>哨兵模式是一种特殊的模式，哨兵是一个独立的进程，它会独立运行，其原理是哨兵通过发送命令，等待 redis 服务器响应，从而监控运行的多个 redis 实例。一般哨兵也会配置集群</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/1586252371307203.png" alt="img"></p>
<h2 id="15、redis-缓存穿透、击穿和雪崩"><a href="#15、redis-缓存穿透、击穿和雪崩" class="headerlink" title="15、redis 缓存穿透、击穿和雪崩"></a>15、redis 缓存穿透、击穿和雪崩</h2><blockquote>
<p>缓存穿透（查不到）</p>
</blockquote>
<p>用户查询一个数据，发现 redis 内存数据库中没有，也就是缓存没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败，当用户很多时，缓存都没有命中，于是都去请求了持久层的数据库，这个会给持久层数据库库造成很大的压力，这时候就会出现缓存穿透</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>布隆过滤器：是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力</li>
<li>缓存空对象：当存储层不命中后，即使是返回的空对象也将其缓存起来，同时设置一个过期时间，之后再访问这个数据就会从缓存中获取，保护了后端数据源<ul>
<li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多空值的键</li>
<li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响</li>
</ul>
</li>
</ol>
<blockquote>
<p>缓存击穿（量太大，缓存过期）</p>
</blockquote>
<p>是指一个非常热点的 key 在不停的扛着大并发的集中访问，当这个 key 失效的瞬间，持续的大并发就会击穿缓存，直接请求数据库，就像在屏幕上凿开了一个洞</p>
<p>当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库压力瞬间过大</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>设置热点数据永不过期</li>
<li>分布式锁：使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其它线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大</li>
</ol>
<blockquote>
<p>缓存雪崩</p>
</blockquote>
<p>是指在某一个时间段，缓存集中失效</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>搭建集群，异地多活</li>
<li>限流降级，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其它线程等待</li>
<li>数据预热，在正式部署之前，把可能被大量访问的数据先访问一遍，这样部分可能被大量访问的数据就会加载到缓存中，在即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://hqzqaq.github.io/2022/09/23/java-redis/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/09/23/smart-doc%E9%9B%86%E6%88%90torna/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            smart-doc集成torna
          
        </div>
      </a>
    
    
      <a href="/2022/09/23/java-rabbitmq/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">java rabbitmq</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> hqz
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="hqz的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/java/">java</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/machineLearning/">机器学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/webGIS/">webGIS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/bigData/">大数据</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/gis/">GIS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/academic/">学术</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/other/">other</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>