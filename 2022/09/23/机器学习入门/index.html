<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>机器学习入门 |  hqz的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-机器学习入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  机器学习入门
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2022-09-23T06:09:04.000Z" itemprop="datePublished">2022-09-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/machineLearning/">machineLearning</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">28.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">102 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>机器学习是一种功能、方法，或者更具体的说是一种算法，它能够赋予<code>机器进行学习</code>的能力，从而使机器完成一些通过编程无法直接实现的功能。</p>
<p>机器学习是利用大量数据训练出一个<code>最优模型</code>，然后再利用此模型预测出其他数据的一种方法。</p>
<span id="more"></span>

<h2 id="1、人工智能"><a href="#1、人工智能" class="headerlink" title="1、人工智能"></a>1、人工智能</h2><p>人工智能（Artificial Intelligence）是计算机科学技术的一个分支，指的是通过机器和计算机来模拟人类智力活动的过程。</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/1F11J4C-1.gif" alt="三者关系"></p>
<h2 id="2、学习形式分类"><a href="#2、学习形式分类" class="headerlink" title="2、学习形式分类"></a>2、学习形式分类</h2><h3 id="2-1、有监督学习"><a href="#2-1、有监督学习" class="headerlink" title="2.1、有监督学习"></a>2.1、有监督学习</h3><p>有监督学习（supervised learning），需要事先需要准备好要<code>输入数据（训练样本）</code>与真实的<code>输出结果（参考答案)</code>，然后通过计算机的学习得到一个预测模型，再用已知的模型去预测未知的样本</p>
<h3 id="2-2、无监督学习"><a href="#2-2、无监督学习" class="headerlink" title="2.2、无监督学习"></a>2.2、无监督学习</h3><p>无监督学习（unsupervised learning）就是在没有“参考答案”的前提下，计算机仅根据样本的特征或相关性，就能实现从样本数据中训练出相应的预测模型。</p>
<p>还有半监督学习和强化学习等</p>
<h2 id="3、预测结果分类"><a href="#3、预测结果分类" class="headerlink" title="3、预测结果分类"></a>3、预测结果分类</h2><h3 id="3-1、回归-amp-分类"><a href="#3-1、回归-amp-分类" class="headerlink" title="3.1、回归&amp;分类"></a>3.1、回归&amp;分类</h3><p>连续和离散是统计学中的一种概念，全称为“连续变量”和“离散变量”</p>
<h3 id="3-2、聚类"><a href="#3-2、聚类" class="headerlink" title="3.2、聚类"></a>3.2、聚类</h3><p>用一个成语表述“物以类聚，人以群分”，将相似的样本聚合在一起后，然后进行分析</p>
<h2 id="4、机器学习术语"><a href="#4、机器学习术语" class="headerlink" title="4、机器学习术语"></a>4、机器学习术语</h2><h3 id="4-1、模型"><a href="#4-1、模型" class="headerlink" title="4.1、模型"></a>4.1、模型</h3><p>可以把它看做一个“魔法盒”，你向它许愿（输入数据），它就会帮你实现愿望（输出预测结果）</p>
<h3 id="4-2、数据集"><a href="#4-2、数据集" class="headerlink" title="4.2、数据集"></a>4.2、数据集</h3><p>表示一个承载数据的集合，数据集可划分为“训练集”和“测试集”，它们分别在机器学习的“训练阶段”和“预测输出阶段”起着重要的作用</p>
<h3 id="4-3、样本-amp-特征"><a href="#4-3、样本-amp-特征" class="headerlink" title="4.3、样本&amp;特征"></a>4.3、样本&amp;特征</h3><p>样本指的是数据集中的数据，一条数据被称为“一个样本”，通常情况下，样本会包含多个特征值用来描述数据</p>
<h3 id="4-4、向量"><a href="#4-4、向量" class="headerlink" title="4.4、向量"></a>4.4、向量</h3><p>向量在线性代数中有着严格的定义，指具有大小和方向的量，数据集中的每一个样本都是一条具有向量形式的数据</p>
<h3 id="4-5、矩阵"><a href="#4-5、矩阵" class="headerlink" title="4.5、矩阵"></a>4.5、矩阵</h3><p>可以看成由向量组成的二维数组，数据集就是以二维矩阵的形式存储数据的</p>
<h3 id="4-6、假设函数-amp-损失函数"><a href="#4-6、假设函数-amp-损失函数" class="headerlink" title="4.6、假设函数&amp;损失函数"></a>4.6、假设函数&amp;损失函数</h3><p>假设函数和损失函数是机器学习中的两个概念，它并非某个模块下的函数方法，而是我们根据实际应用场景确定的一种<code>函数形式</code></p>
<h4 id="4-6-1、假设函数"><a href="#4-6-1、假设函数" class="headerlink" title="4.6.1、假设函数"></a>4.6.1、假设函数</h4><p>假设函数（Hypothesis Function）可表述为<code>y=f(x)</code>其中 x 表示输入数据，而 y 表示输出的预测结果，而这个结果需要不断的优化才会达到预期的结果，否则会与实际值偏差较大。</p>
<h4 id="4-6-2、损失函数"><a href="#4-6-2、损失函数" class="headerlink" title="4.6.2、损失函数"></a>4.6.2、损失函数</h4><p>损失函数（Loss Function）又叫目标函数，简写为 L(x)，这里的 x 是假设函数得出的预测结果“y”，如果 L(x) 的返回值越大就表示预测结果与实际偏差越大，越小则证明预测值越来越“逼近”真实值，这才是机器学习最终的目的。因此损失函数就像一个度量尺，能度量“假设函数”预测结果的优劣，从而做出相应的优化策略。</p>
<h4 id="4-6-3、优化方法"><a href="#4-6-3、优化方法" class="headerlink" title="4.6.3、优化方法"></a>4.6.3、优化方法</h4><p>“优化方法”可以理解为假设函数和损失函数之间的沟通桥梁。通过 L(x) 可以得知假设函数输出的预测结果与实际值的偏差值，当该值较大时就需要对其做出相应的调整，这个调整的过程叫做“参数优化”，可以通过<code>梯度下降、牛顿方与拟牛顿法、共轭梯度法</code>进行参数调优</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/1F30JR3-3.gif" alt="函数关系"></p>
<h3 id="4-7、拟合-amp-过拟合-amp-欠拟合"><a href="#4-7、拟合-amp-过拟合-amp-欠拟合" class="headerlink" title="4.7、拟合&amp;过拟合&amp;欠拟合"></a>4.7、拟合&amp;过拟合&amp;欠拟合</h3><p>拟合是机器学习中的重要概念，机器学习的研究对象就是让模型能更好的拟合数据</p>
<h4 id="4-7-1、拟合"><a href="#4-7-1、拟合" class="headerlink" title="4.7.1、拟合"></a>4.7.1、拟合</h4><p>“拟合”就是把平面坐标系中一系列散落的点，用一条光滑的曲线连接起来，因此拟合也被称为“曲线拟合”，拟合的曲线一般用函数进行表示，但是由于拟合曲线会存在许多种连接方式，因此就会出现多种拟合函数。通过研究、比较确定一条最佳的“曲线”也是机器学习中一个重要的任务</p>
<h4 id="4-7-2、过拟合"><a href="#4-7-2、过拟合" class="headerlink" title="4.7.2、过拟合"></a>4.7.2、过拟合</h4><p>过拟合（overfitting）与是机器学习模型训练过程中经常遇到的问题，所谓过拟合，通俗来讲就是模型的泛化能力较差，也就是过拟合的模型在训练样本中表现优越，但是在验证数据以及测试数据集中表现不佳</p>
<h4 id="4-7-3、欠拟合"><a href="#4-7-3、欠拟合" class="headerlink" title="4.7.3、欠拟合"></a>4.7.3、欠拟合</h4><p>欠拟合（underfitting）恰好与过拟合相反，它指的是“曲线”不能很好的“拟合”数据。在训练和测试阶段，欠拟合模型表现均较差，无法输出理想的预测结果。造成欠拟合的主要原因是由于没有选择好合适的特征值</p>
<h2 id="5、机器学习环境搭建"><a href="#5、机器学习环境搭建" class="headerlink" title="5、机器学习环境搭建"></a>5、机器学习环境搭建</h2><h3 id="5-1、numpy"><a href="#5-1、numpy" class="headerlink" title="5.1、numpy"></a>5.1、numpy</h3><p>是 Python 科学计算的基础库，提供了多维数组处理、线性代数、傅里叶变换、随机数生成等非常有用的数学工具。</p>
<h3 id="5-2、pandas"><a href="#5-2、pandas" class="headerlink" title="5.2、pandas"></a>5.2、pandas</h3><p>属于 Python 第三方数据处理库，它基于 NumPy 构建而来，主要用于数据的处理与分析。Pandas 提供了一个简单高效的 DataFrame 对象（类似于电子表格），它能够完成数据的清洗、预处理以及数据可视化工作等。除此之外，Pandas 能够非常轻松地实现对任何文件格式的读写操作，比如 CSV 文件、json 文件、excel 文件。</p>
<h3 id="5-3、scikit-learn"><a href="#5-3、scikit-learn" class="headerlink" title="5.3、scikit-learn"></a>5.3、scikit-learn</h3><p>是一个基于 Python 语言的机器学习算法库，建立在 NumPy、Scipy 与 Matplotlib 之上，它提供了大量机器学习算法接口（API）。</p>
<p>Scikit-Learn 的基本功能主要被分为六大部分：分类，回归，聚类，数据降维，模型选择和数据预处理。</p>
<h2 id="6、线性回归算法"><a href="#6、线性回归算法" class="headerlink" title="6、线性回归算法"></a>6、线性回归算法</h2><p>线性回归算法（Linear Regression），“线性”代表线性模型，而“回归”则表示回归问题。线性回归主要用来解决回归问题，也就是预测连续值的问题，是利用线性模型来“预测”真实值的过程，而能满足这样要求的数学模型被称为“回归模型”。最简单的线性回归模型是我们所熟知的一次函数（即 y&#x3D;kx+b）</p>
<blockquote>
<p>还有另外一种回归模型，也就是非线性模型(nonlinear model)，它指因变量与自变量之间的关系不能表示为线性对应关系(即不是一条直线)，比如我们所熟知的对数函数、指数函数、二次函数等。</p>
</blockquote>
<h3 id="6-1、线性回归方程"><a href="#6-1、线性回归方程" class="headerlink" title="6.1、线性回归方程"></a>6.1、线性回归方程</h3><p>$$<br>\large<br>y &#x3D; w_1x + b<br>$$</p>
<p>以上函数可作为线性模型的“假设函数”，其中 x 表示输入的样本数据，y 表示输出的预测结果，而 &#x3D;&#x3D;w<del>1</del>&#x3D;&#x3D; 指的是线性回归模型的权值参数，b 指的是线性回归模型的“偏差值”。</p>
<blockquote>
<p>权值，可理解为个不同“特征”对于预测结果的重要性。权值系数越大，那么这一项属性值对最终结果的影响就越大。</p>
</blockquote>
<h2 id="7、数学解析线性回归"><a href="#7、数学解析线性回归" class="headerlink" title="7、数学解析线性回归"></a>7、数学解析线性回归</h2><h3 id="7-1、假设函数"><a href="#7-1、假设函数" class="headerlink" title="7.1、假设函数"></a>7.1、假设函数</h3><p>$$<br>\large<br>Y_1 &#x3D; w^TX_1 + b \text{ 或 } \<br>f(x) &#x3D; w^TX_1 + b<br>$$</p>
<p><code>f(x) </code>仍然代表预测结果， &#x3D;&#x3D;X<del>1</del>&#x3D;&#x3D; 表示数据样本， <code>b </code> 表示用来调整预测结果的“偏差度量值”，而 &#x3D;&#x3D;w^T^&#x3D;&#x3D; 表示权值系数的转置。矩阵相乘法是一个求两个向量<strong>点积</strong>的过程，也就是按位相乘，然后求和。</p>
<h3 id="7-2、损失函数"><a href="#7-2、损失函数" class="headerlink" title="7.2、损失函数"></a>7.2、损失函数</h3><p>损失函数就像一个衡量尺，这个函数的<code>返回值越大</code>就表示<code>预测结果与真实值偏差越大</code>。可以用预测值 Y<del>1</del> 减去真实值 Y，再用平方消除负数。<br>$$<br>\large<br>loss &#x3D; \frac{\sum(w^TX_1 + b - Y)^2}{n}<br>$$</p>
<h2 id="8、梯度下降求极值"><a href="#8、梯度下降求极值" class="headerlink" title="8、梯度下降求极值"></a>8、梯度下降求极值</h2><p><code>梯度</code>下降是机器学习中常用的一种优化方法，主要用来<font color="orange">解决求极小值的问题</font>，某个函数在某点的<code>梯度</code>指向该函数取得<code>最大值</code>的方向，那么它的<code>反反向</code>自然就是取得<code>最小值</code>的方向。在解决线性回归和 Logistic（逻辑） 回归问题时，梯度下降方法有着广泛的应用。</p>
<p><code>梯度</code>是微积分学的术语，它本质上是一个<code>向量</code>，表示<code>函数在某一点处的方向导数上沿着特定的方向取得最大值</code>，即函数在该点处沿着该方向变化最快，变化率最大。梯度下降法的计算过程就是<code>沿梯度方向</code>求解极小值，当然你也可以沿梯度上升的方向求解极大值。</p>
<p>以线性回归的损失函数为例，梯度下降作为一种优化方法，其目的是要使得损失值最小。因此“梯度下降”就需要控制损失函数中的 <code>w</code> 和 <code>b</code> 参数来找到最小值。比如控制 w 就会得到如下方法：<br>$$<br>\large<br>w_新 &#x3D; w_旧 - 学习率 * 损失值<br>$$</p>
<ul>
<li>通过梯度下降计算极小值时，需要对损失函数的 <code>w</code> 求偏导求得，这个偏导也就是“梯度”，通过损失值来调节 <code>w</code>，不断缩小损失值直到最小</li>
<li>“学习率”是一个由<code>外部输入的参数</code>，被称为<code>“超参数”</code>，可以形象地把它理解为下山时走的<code>“步长”</code>大小，想要 w 多调整一点，就把学习率调高一点。不过学习率也不是越高越好，过高的学习率可能导致调整幅度过大，导致无法求得真正的最小值。当损失函数取得极小值时，此时的参数值被称为<code>“最优参数”</code>。因此，在机器学习中最重要的一点就是寻找“最优参数”</li>
<li>梯度下降还包括：<code>批量梯度下降（BGD）</code>、随机梯度下降（SGD）、小批量梯度下降（MBGD），其中批量梯度下降是最常用的</li>
</ul>
<h2 id="9、sklearn"><a href="#9、sklearn" class="headerlink" title="9、sklearn"></a>9、sklearn</h2><p>Scikit-learn 简称 <strong>sklearn</strong> 是基于 Python 语言实现的机器学习算法库，它包含了常用的机器学习算法，比如回归、分类、聚类、支持向量机、随机森林等等。同时，它使用 NumPy 库进行高效的科学计算，比如线性代数、矩阵等等。</p>
<p>常用算法库：</p>
<ul>
<li>·linear_model：线性模型算法族库，包含了线性回归算法，以及 Logistic 回归算法，它们都是基于线性模型</li>
<li>.naiv_bayes：朴素贝叶斯模型算法库</li>
<li>.tree：决策树模型算法库</li>
<li>.svm：支持向量机模型算法库</li>
<li>.neural_network：神经网络模型算法库</li>
<li>.neightbors：最近邻算法模型库</li>
</ul>
<h3 id="9-1、线性回归算法的简单实现"><a href="#9-1、线性回归算法的简单实现" class="headerlink" title="9.1、线性回归算法的简单实现"></a>9.1、线性回归算法的简单实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="comment"># 使用matplotlib绘制图像</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 使用numpy准备数据集</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">line_model_learn</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># 准备自变量x,3到6的区间均分间隔30份数</span></span><br><span class="line">    x = np.linspace(<span class="number">3</span>, <span class="number">6</span>, <span class="number">40</span>)</span><br><span class="line">    <span class="comment"># 准备因变量y，这一个关于x的假设函数</span></span><br><span class="line">    y = <span class="number">3</span> * x + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加代码，扰乱点的分布</span></span><br><span class="line">    x = x + np.random.rand(<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 由于fit 需要传入二维矩阵数据，因此需要处理x，y的数据格式,将每个样本信息单独作为矩阵的一行</span></span><br><span class="line">    x = [[i] <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">    y = [[i] <span class="keyword">for</span> i <span class="keyword">in</span> y]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建线性回归模型</span></span><br><span class="line">    model = linear_model.LinearRegression()</span><br><span class="line">    <span class="comment"># 训练模型，&quot;喂入&quot;数据</span></span><br><span class="line">    model.fit(x, y)</span><br><span class="line">    y_ = model.predict(data)</span><br><span class="line">    <span class="built_in">print</span>(y_)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查看w和b的值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;w值为:&quot;</span>, model.coef_)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b截距值为:&quot;</span>, model.intercept_)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据集绘制,散点图，图像满足函假设函数图像</span></span><br><span class="line">    plt.scatter(x, y)</span><br><span class="line">    <span class="comment"># 绘制最佳拟合直线</span></span><br><span class="line">    plt.plot(data, y_, color=<span class="string">&quot;red&quot;</span>, linewidth=<span class="number">3.0</span>, linestyle=<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    plt.legend([<span class="string">&quot;func&quot;</span>, <span class="string">&quot;Data&quot;</span>], loc=<span class="number">0</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 准备测试数据 x_</span></span><br><span class="line">    x_ = [[<span class="number">4</span>], [<span class="number">5</span>], [<span class="number">6</span>]]</span><br><span class="line">    line_model_learn(x_)</span><br></pre></td></tr></table></figure>

<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/image-20220730160737417.png" alt="拟合直线绘制"></p>
<h3 id="9-2、线性回归总结"><a href="#9-2、线性回归总结" class="headerlink" title="9.2、线性回归总结"></a>9.2、线性回归总结</h3><p>线性回归适用于有<code>监督学习</code>的回归问题，首先在构建线性模型前，需要准备好待输入的数据集，数据集按照需要可划分为<code>训练集</code>和<code>测试集</code>，使用训练集中的向量 X 与向量 Y 进行模型的训练，其中<code>向量 Y 表示对应 X 的结果数值</code>(也就是<code>“参考答案”</code>)；而输出时需要使用测试集，输入测试 X 向量输出预测结果向量 Y。</p>
<p>线性回归主要解决了以下三个问题：</p>
<ul>
<li>第一，为假设函数设定了参数 w，通过假设函数画出线性“拟合”直线。</li>
<li>第二，将预测值带入损失函数，计算出一个损失值。</li>
<li>第三，通过得到的损失值，利用梯度下降等优化方法，不断调整 w 参数，使得损失值取得最小值。我们把这个<code>优化参数值的过程</code>叫做<code>“线性回归”的学习过程</code>。</li>
</ul>
<h2 id="10、Logistic回归算法"><a href="#10、Logistic回归算法" class="headerlink" title="10、Logistic回归算法"></a>10、Logistic回归算法</h2><p>Logistic 回归算法，又叫做逻辑回归算法，或者 LR 算法（Logistic Regression），是针对“分类问题”的算法。分类问题同样也可以基于<code>“线性模型”</code>构建。“线性模型”最大的特点就是“直来直去”不会打弯，而我们知道，分类问题的预测结果是<code>“离散的”</code>，即对输出数据的类别做判断。比如将类别预设条件分为<code>“0”类</code>和<code>“1”类</code>（或者“是”或者“否”）那么图像只会在 “0”和“1”之间上下起伏，如下图所示：</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/1G313IU-0.gif" alt="离散型数据"></p>
<h3 id="10-1、Logistic-函数"><a href="#10-1、Logistic-函数" class="headerlink" title="10.1、Logistic 函数"></a>10.1、Logistic 函数</h3><blockquote>
<p>在机器学习中，Logistic 函数通常用来解决二元分类问题，也就是涉及两个预设类别的问题，而当类别数量超过两个时就需要使用 Softmax 函数来解决。</p>
</blockquote>
<p>在神经网络算法中被称为 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Sigmoid%E5%87%BD%E6%95%B0/7981407?fr=aladdin"><strong>Sigmoid 函数</strong></a>，也有人称它为 <strong>Logistic 曲线</strong>。</p>
<p>函数图像如下图所示：</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/1G3134434-1.gif" alt="Logistic 曲线函数"></p>
<p>数学表达式如下：<br>$$<br>\large<br>Logistic(z)&#x3D;\frac{1}{1 + e^{-z}}<br>$$<br>e 称为自然常数，也就是一个固定值的“常量”，e^-z^ 是以 e 为底、z 为变量的指数函数。</p>
<p><code>Logistic 函数</code>也称为 <code>S 型生长曲线</code>，取值范围为 (0,1)，它可以将一个实数映射到 (0,1) 的区间，非常适合做二元分类。当 z&#x3D;0 时，该函数的取值为 0.5，随着 z 的增大，对应的函数值将逼近于 1；而随着 z 的减小，其函数值将逼近于 0。</p>
<p>对于 Logistic 函数而言，坐标轴 0 是一个有着特殊意义坐标，越靠近 0 和越远离 0 会出现两种截然不同的情况：<code>任何大于 0.5 的数据都会被划分到 “1”类中；而小于 0.5 会被归如到 “0”类</code>。</p>
<p><strong>特别是：</strong></p>
<ol>
<li><p>当 x 轴坐标取值缩小时会出现以下图像：</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/1G31340K-3.gif" alt="x 取值缩小时 Logistic 函数"></p>
<p>由此可见 Logistic 回归算法属于“线性”模型</p>
</li>
<li><p>当 x 逐渐放大时则会出现以下图像：</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/1G3136241-4.gif" alt="x 取值放大时 Logistic 函数"></p>
<p>当 x 增大到一定程度时，Logistic 函数图像变成了“台阶”式图像，由此可知，该函数能够很好的“拟合”二分类问题函数图像。在数学像 Logistic 函数这样的函数被称为<code>”阶跃函数“</code></p>
</li>
</ol>
<h3 id="10-2、分类数据表示形式"><a href="#10-2、分类数据表示形式" class="headerlink" title="10.2、分类数据表示形式"></a>10.2、分类数据表示形式</h3><h4 id="10-2-1、向量形式"><a href="#10-2-1、向量形式" class="headerlink" title="10.2.1、向量形式"></a>10.2.1、向量形式</h4><p>向量形式是应用最多的形式，向量中的元素按顺序代表“类别”，例如有以下三个类别，分别是 a&#x2F;b&#x2F;c 三类，此时就可以使用 [1,2,3] 来分别代表上述三类。预测结果为哪一类，向量中的元素就对应哪个元素，比如当预测结果为 c 类的时候，则输出以下数据：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0,0,3]</span><br></pre></td></tr></table></figure>

<h4 id="10-2-2、数字形式"><a href="#10-2-2、数字形式" class="headerlink" title="10.2.2、数字形式"></a>10.2.2、数字形式</h4><p>数字形式是一种最简单的分类方式，我们可以用 0 代表“负类”（即 x &lt; 0时的取值），而用“1”代表正类（即 x&gt;0 时的取值），那么当预测结果输出“1”就代表正类，而预测结果输出“0”代表“负类”。按照约定俗成，我们一般采用 “1”代表正类，而 “-1”或者“0”代表“负类”。用代码的表示数字形式的中心思想，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以 0 为节将其分开</span></span><br><span class="line"><span class="keyword">if</span> (logistic函数输出的是连续值&gt;<span class="number">0</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="10-2-3、概率形式"><a href="#10-2-3、概率形式" class="headerlink" title="10.2.3、概率形式"></a>10.2.3、概率形式</h4><p>在有些实际场景中，无法准确的判断某个“样本”属于哪个类别，此时就可以使用“概率”的形式来判断“样本”属于哪个类别的几率大，比如对某个“样本”有如下预测结果：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0.8,0.1,0.1]</span><br></pre></td></tr></table></figure>

<p>该样本属于 a 类的概率最大，因此可以认定该样本从属于 a 类。</p>
<h3 id="10-3、Logistic函数数学解析"><a href="#10-3、Logistic函数数学解析" class="headerlink" title="10.3、Logistic函数数学解析"></a>10.3、Logistic函数数学解析</h3><h4 id="10-3-1、假设函数"><a href="#10-3-1、假设函数" class="headerlink" title="10.3.1、假设函数"></a>10.3.1、假设函数</h4><p>$$<br>\large<br>H(x) &#x3D; \frac{1}{1 + e^{-(w^Tx_i + b)}}<br>$$</p>
<p>上述公式和 Logistic 函数基本一致，只不过把它换成了关于 <code>x</code> 的表达式，并将幂指数 <code>x</code> 换成了 “线性函数”表达式。H(x) 的函数图像呈现 S 形分布，从而能够预测出离散的输出结果。</p>
<h4 id="10-3-2、损失函数"><a href="#10-3-2、损失函数" class="headerlink" title="10.3.2、损失函数"></a>10.3.2、损失函数</h4><p>$$<br>\large<br>L(x) &#x3D; -ylogH(x) - (1-y)log(1 - H(x))<br>$$</p>
<p>由以下公式演化而来，解决该公式不能使用梯度下降等优化方法的问题：<br>$$<br>\large<br>L(x) &#x3D; -H(x_i)^{y_i}(1 - H(x_i))^{1-y_i}<br>$$<br>当 y&#x3D;1 时，如果预测正确，预测值则无限接近 1，也即 H(x<sub>i</sub>)<sup>y<sup>i</sup></sup> 的值为 1，损失值则为 -1；如果预测错误，H(x<sub>i</sub>)<sup>y<sub>i</sub></sup> 的值为 0，损失值也为 0。<code>预测错误的损失值确实比预测正确的损失值大（0 &gt; -1）</code>，满足要求。</p>
<h4 id="10-3-3、优化方法"><a href="#10-3-3、优化方法" class="headerlink" title="10.3.3、优化方法"></a>10.3.3、优化方法</h4><p>将 Logistic 函数的输出记作 z 可得如下公式：<br>$$<br>\large<br>z &#x3D; w_0x_0 + w_1x_1 + \cdots + w_nx_n<br>$$<br>采用向量的形式可以写为：<br>$$<br>\large<br>z &#x3D; w^Tx<br>$$<br>表示将这两个数值向量对应元素相乘然后全部加起来即得到 z 值。其中的 x 是分类器的输入数据，向量 w （最佳参数）会使得分类器尽可能的精确。</p>
<h4 id="10-3-4、梯度上升优化方法"><a href="#10-3-4、梯度上升优化方法" class="headerlink" title="10.3.4、梯度上升优化方法"></a>10.3.4、梯度上升优化方法</h4><p>梯度上升基于的思想是：要找到某函数的最大值，最好的方法是沿着该函数的梯度方向寻找，如果把梯度记为 <code>▽</code>，那么关于 f(x,y) 有以下表达式：<br>$$<br>\Large<br>▽f(x,y) &#x3D; \left(<br>\begin{matrix}<br>\frac{\partial f(x,y)}{\partial x} \<br>\<br>\frac{\partial f(x,y)}{\partial y}<br>\end{matrix}<br>\right)<br>$$<br>该函数分别对 x 与 y 求的偏导数，其中关于 x 的偏导数表示沿着 x 的方向移动，而关于 y 的偏导数一个表示沿 y 的方向移。其中，函数f(x,y) 必须要在待计算的点上可导。在梯度上升的过程中，<code>梯度总是指向函数值增长最快的方向</code>，我们可以把每移动一次的“步长”记为 <code>α</code> 。用向量来表示的话，其公式如下：<br>$$<br>\large<br>w_1 &#x3D; w + \partial▽_wf(w)<br>$$<br>在梯度上升的过程中，上述公式将一直被迭代执行，直至达到某个停止条件为止，比如达到某个指定的值或者某个被允许的误差范围之内。</p>
<h3 id="10-4、sklearn应用Logistic回归算法"><a href="#10-4、sklearn应用Logistic回归算法" class="headerlink" title="10.4、sklearn应用Logistic回归算法"></a>10.4、sklearn应用Logistic回归算法</h3><h4 id="10-4-1、范数"><a href="#10-4-1、范数" class="headerlink" title="10.4.1、范数"></a>10.4.1、范数</h4><p>范数又称为“正则项”，它是机器学习中会经常遇到的术语，它表示了一种运算方式，常见的范数主要分为两种：L1 和 L2。</p>
<ol>
<li><p><strong>L1 范数</strong></p>
<p>表示向量中每个元素绝对值的和，根据定义，L1 范数的计算分两步，首先逐个求得元素的绝对值，然后相加求和即可。<br>$$<br>\large<br>||x||<em>1 &#x3D; \sum\limits</em>{i &#x3D; 1}^n|x_i|<br>$$<br>两个绝对值符号表示范数。 </p>
</li>
<li><p><strong>L2 范数</strong></p>
<p>表示向量中每个元素的平方和的平方根，根据定义，L2 范数的计算分三步，首先逐个求得元素的平方，然后相加求和，最后求和的平方根。<br>$$<br>\large<br>||x||<em>2 &#x3D; \sqrt{\sum\limits</em>{i &#x3D; 1}^n{x_i^2}}<br>$$</p>
</li>
</ol>
<h4 id="10-4-2、回归类算法"><a href="#10-4-2、回归类算法" class="headerlink" title="10.4.2、回归类算法"></a>10.4.2、回归类算法</h4><ol>
<li><p>Rodge 类</p>
<p>Ridge 回归算法，又称“岭回归算法”主要用于预测回归问题，是在线性回归的基础上添加了 L2 正则项，使得权重 w 的分布更加均匀，其损失函数如下：<br>$$<br>\large<br>L(x) &#x3D; ||X_w - y||_2^2 + a||w||_2^2<br>$$<br>损失函数的左侧与线性回归算法的损失函数一致。只是在最后添加右侧的 L2 正则项，其中 a 只是一个常数，需要根据经验设置。</p>
<blockquote>
<p>线性回归函数的 1&#x2F;n 在优化过程的运算中不会影响结果，它只是一个常量而已，而常量的导数是 0。</p>
</blockquote>
</li>
<li><p>Lasso 类</p>
<p>Lasso 回归算法，使用 L1 正则项，可以预测回归问题，其损失函数的表达式如下（求最小损失值）：<br>$$<br>\large<br>L(x) &#x3D; \frac{1}{2n}||X_w - y||_2^2 + a||w||_1<br>$$<br>上述表达式的左侧与 Ridge 回归算法的损失函数基本一致，只是将右侧的 L2 范数替换成了 L1 范数，而且左侧式子相比线性回归表达式而言，多了一个 1&#x2F;2n，但实际的优化过程中，它并不会对权重 w 产生影响。</p>
</li>
</ol>
<h4 id="10-4-3、Logistic-回归的实现"><a href="#10-4-3、Logistic-回归的实现" class="headerlink" title="10.4.3、Logistic 回归的实现"></a>10.4.3、Logistic 回归的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># logistic算法</span></span><br><span class="line"><span class="comment"># 从 scikit-learn库导入线性模型中的logistic回归算法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="comment"># 导入sklearn 中的自带数据集 鸢尾花数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="comment"># skleran 提供的分割数据集的方法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 载入鸢尾花数据集</span></span><br><span class="line">    iris_dataset = load_iris()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data 数组的每一行对应一朵花，列代表每朵花的四个测量数据，分别是：花瓣的长度，宽度，花萼的长度、宽度</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data数组类型: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(iris_dataset[<span class="string">&#x27;data&#x27;</span>])))</span><br><span class="line">    <span class="comment"># 前五朵花的数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;前五朵花数据:\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(iris_dataset[<span class="string">&#x27;data&#x27;</span>][:<span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分割数据集训练集，测试集</span></span><br><span class="line">    <span class="comment"># 打乱数据集，并对其进行拆分。该函数默认将 75% 的行数据及对应标签作为训练集，另外 25% 数据作为测试集。</span></span><br><span class="line">    X_train, X_test, Y_train, Y_test = train_test_split(iris_dataset[<span class="string">&#x27;data&#x27;</span>], iris_dataset[<span class="string">&#x27;target&#x27;</span>], random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    <span class="comment"># 设置最大迭代次数为3000，默认为1000.不更改会出现警告提示</span></span><br><span class="line">    log_reg = LogisticRegression(max_iter=<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给模型喂入数据</span></span><br><span class="line">    clm = log_reg.fit(X_train, Y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用模型对测试集分类预测,并打印分类结果</span></span><br><span class="line">    <span class="built_in">print</span>(clm.predict(X_test))</span><br><span class="line">    <span class="comment"># 最后使用性能评估器，测试模型优良，用测试集对模型进行评分</span></span><br><span class="line">    <span class="built_in">print</span>(clm.score(X_test, Y_test))</span><br></pre></td></tr></table></figure>

<p>Logistic 算法适用于<code>分类问题</code>，该算法在处理二分类问题上表现优越，但在<code>多分类（二个以上）问题上容易出现欠拟合</code>。Logistic 算法除了适用于回归分类问题，还可以作为神经网络算法的<code>激活函数</code>（即 Sigmoid 函数）。</p>
<p>算法只有<strong>合适</strong>与<strong>不合适</strong>，每个算法都有其适用的场景，没有优劣之分。</p>
<h2 id="11、KNN-最邻近分类算法"><a href="#11、KNN-最邻近分类算法" class="headerlink" title="11、KNN 最邻近分类算法"></a>11、KNN 最邻近分类算法</h2><p>K 最近邻分类算法，简称 KNN（K-Nearest-Neighbor），它是有监督学习分类算法的一种。所谓 K 近邻，就是 K 个最近的邻居。比如对一个样本数据进行分类，可以用与它最邻近的 K 个样本来表示它，这与俗语“近朱者赤，近墨者黑”是一个道理。</p>
<p>核心关键词：“<strong>少数服从多数</strong>”、“<strong>距离</strong>”</p>
<h3 id="11-1、KNN-算法原理"><a href="#11-1、KNN-算法原理" class="headerlink" title="11.1、KNN 算法原理"></a>11.1、KNN 算法原理</h3><p>为了判断未知样本的类别，以<code>所有已知类别的样本</code>作为参照来计算<code>未知样本与所有已知样本的距离</code>，然后从中选取与<code>未知样本距离最近的 K 个已知样本</code>，并根据<code>少数服从多数</code>的投票法则（majority-voting），将未知样本与 K 个最邻近样本中<code>所属类别占比较多</code>的归为一类。</p>
<p>如果一个样本在特征空间中存在 K 个与其相邻的的样本，其中某一类别的样本数目较多，则待预测样本就属于这一类，并具有这个类别相关特性。该方法在确定分类决策上只依据<code>最邻近的一个或者几个样本的类别来决定待分样本所属的类别</code>。</p>
<p>KNN 算法简单易于理解，无须估计参数，与训练模型，适合于<code>多分类问题、OCR光学模式识别、文本分类等领域</code>。但它的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有很能导致当输入一个新样本时，该样本的 K 个邻居中大容量类的样本占多数，而此时只依照数量的多少去预测未知样本的类型，就会可能增加预测错误概率。此时，可以采用对样本取<strong>“权值”</strong>的方法来改进。</p>
<h3 id="11-2、KNN-算法流程"><a href="#11-2、KNN-算法流程" class="headerlink" title="11.2、KNN 算法流程"></a>11.2、KNN 算法流程</h3><ul>
<li>准备数据，对数据进行预处理 。</li>
<li>计算测试样本点（也就是待分类点）到其他每个样本点的距离（选定度量距离的方法）。</li>
<li>对每个距离进行排序，然后选择出距离最小的 K 个点。</li>
<li>对 K 个点所属的类别进行比较，按照少数服从多数的原则（多数表决思想），将测试样本点归入到 K 个点中占比最高的一类中。</li>
</ul>
<h3 id="11-3、sklearn-实现-KNN-分类算法"><a href="#11-3、sklearn-实现-KNN-分类算法" class="headerlink" title="11.3、sklearn 实现 KNN 分类算法"></a>11.3、sklearn 实现 KNN 分类算法</h3><p>Pyhthon Sklearn 机器学习库提供了 neighbors 模块，该模块下提供了 KNN 算法的常用方法，如下所示：</p>
<table>
<thead>
<tr>
<th>类方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>KNeighborsClassifier</td>
<td>KNN 算法解决分类问题</td>
</tr>
<tr>
<td>KNeighborsRegressor</td>
<td>KNN 算法解决回归问题</td>
</tr>
<tr>
<td>RadiusNeighborsClassifier</td>
<td>基于半径来查找最近邻的分类算法</td>
</tr>
<tr>
<td>NearestNeighbors</td>
<td>基于无监督学习实现KNN算法</td>
</tr>
<tr>
<td>KDTree</td>
<td>无监督学习下基于 KDTree 来查找最近邻的分类算法</td>
</tr>
<tr>
<td>BallTree</td>
<td>无监督学习下基于 BallTree 来查找最近邻的分类算法</td>
</tr>
</tbody></table>
<p>调用 <code>KNeighborsClassifier</code> 实现 KNN 分类算法。下面对 Sklearn 自带的<strong>“红酒数据集”</strong>进行 KNN 算法分类预测。最终实现向训练好的模型喂入数据，输出相应的红酒类别，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载红酒数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="comment"># KNN分类算法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="comment"># 分割训练集与测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 导入numpy</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    wine_dataset = load_wine()</span><br><span class="line">    <span class="comment"># 查看数据集对应的键</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;红酒数据集的键:\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(wine_dataset.keys()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数据集描述:\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(wine_dataset[<span class="string">&#x27;data&#x27;</span>].shape))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data 为数据集数据;target 为样本标签</span></span><br><span class="line">    <span class="comment"># 分割数据集，比例为 训练集：测试集 = 8:2</span></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(wine_dataset[<span class="string">&#x27;data&#x27;</span>], wine_dataset[<span class="string">&#x27;target&#x27;</span>], </span><br><span class="line">                                                        test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建knn分类模型，并指定 k 值</span></span><br><span class="line">    KNN = KNeighborsClassifier(n_neighbors=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用训练集训练模型</span></span><br><span class="line">    KNN.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评估模型的得分</span></span><br><span class="line">    score = KNN.score(X_test, y_test)</span><br><span class="line">    <span class="built_in">print</span>(score)</span><br><span class="line">    <span class="comment"># 给出一组数据对酒进行分类</span></span><br><span class="line">    X_wine_test = np.array([[<span class="number">11.8</span>, <span class="number">4.39</span>, <span class="number">2.39</span>, <span class="number">29</span>, <span class="number">82</span>, <span class="number">2.86</span>, <span class="number">3.53</span>, <span class="number">0.21</span>, <span class="number">2.85</span>, <span class="number">2.8</span>, <span class="number">.75</span>, <span class="number">3.78</span>, <span class="number">490</span>]])</span><br><span class="line">    predict_result = KNN.predict(X_wine_test)</span><br><span class="line">    <span class="built_in">print</span>(predict_result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分类结果：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(wine_dataset[<span class="string">&#x27;target_names&#x27;</span>][predict_result]))</span><br></pre></td></tr></table></figure>

<h2 id="12、朴素贝叶斯分类算法"><a href="#12、朴素贝叶斯分类算法" class="headerlink" title="12、朴素贝叶斯分类算法"></a>12、朴素贝叶斯分类算法</h2><p>朴素贝叶斯（Naive Bayesian algorithm）是<code>有监督学习</code>的一种<code>分类算法</code>，它基于“贝叶斯定理”实现，而贝叶斯定理是基于概率论和统计学的相关知识实现的。</p>
<h3 id="12-1、贝叶斯公式"><a href="#12-1、贝叶斯公式" class="headerlink" title="12.1、贝叶斯公式"></a>12.1、贝叶斯公式</h3><p>$$<br>\large<br>P(A|B) &#x3D; \frac{P(B|A)P(A)}{P(B)}<br>$$</p>
<ul>
<li>P(A) 这是概率中最基本的符号，表示 A 出现的概率。比如在投掷骰子时，P(2) 指的是骰子出现数字“2”的概率，这个概率是 六分之一，也称之为<code>“先验概率”</code></li>
<li>P(B|A) 是<strong>条件概率</strong>的符号，表示事件 A 发生的条件下，事件 B 发生的概率，条件概率是“贝叶斯公式”的关键所在，它也被称为<code>“似然度”</code>。</li>
<li>P(A|B) 是<strong>条件概率</strong>的符号，表示事件 B 发生的条件下，事件 A 发生的概率，这个计算结果也被称为<code>“后验概率”</code>。</li>
</ul>
<p>贝叶斯公式可以预测事件发生的概率，两个本来相互独立的事件，发生了某种“相关性”，此时就可以通过“贝叶斯公式”实现预测。</p>
<p>朴素贝叶斯是一种简单的贝叶斯算法，因为贝叶斯定理涉及到了概率学、统计学，其应用相对复杂，因此我们只能以简单的方式使用它，比如<code>天真的认为，所有事物之间的特征都是相互独立的，彼此互不影响</code>。</p>
<h3 id="12-2、算法原理"><a href="#12-2、算法原理" class="headerlink" title="12.2、算法原理"></a>12.2、算法原理</h3><p>贝叶斯公式将多特征分类问题表达出来，如下所示：<br>$$<br>\large<br>P(y|x_1,\cdots,x_n) &#x3D; \frac{P(y)P(x_1,\cdots,x_n|y)}{P(x_1,\cdots,x_n)}<br>$$<br>数据集有时并不是很完全的，总会因为某些原因存在一些缺失和收集不全的现象，所以特征 x 越多这个问题就会越突出，统计这些特征出现的概率就越困难。为了避免这一问题，朴素贝叶斯算法做了一个假设，即<code>特征之间相互独立，互不影响</code>，由此以来，就可以简化为以下式子来求解某个特征的似然度：<br>$$<br>\large<br>P(x_i|y,x_1,\cdots,x_{i-1},x_{i+1},\cdots,x_n) &#x3D; P(x_i|y)<br>$$<br>“朴素贝叶斯算法”利用<strong>后验概率</strong>进行预测，其核心方法是通过<strong>似然度</strong>预测后验概率。在使用朴素贝叶斯算法解决分类问题，其实就是<code>不断提高似然度的过程</code>，可以理解为<code>后验概率正比于似然度</code>，如果提高了似然度，那么也会达到提高后验概率的目的，记做如下式子：<br>$$<br>\large<br>P(y|x_1,\cdots,x_n) \propto P(y)\prod\limits_{i &#x3D; 1}^{n}P(x_i|y)<br>$$<br>上述式子中 <code>∝</code> 表示正比于，而 <code>∏</code> 则是连乘符号（即概率相乘）表示了不同特征同时发生的概率。</p>
<h3 id="12-3、朴素贝叶斯优化方法"><a href="#12-3、朴素贝叶斯优化方法" class="headerlink" title="12.3、朴素贝叶斯优化方法"></a>12.3、朴素贝叶斯优化方法</h3><p>朴素贝叶斯算法更像是一种统计方法，通过比较<code>不同特征与类之间的似然度关系</code>，最后把<strong>似然度最大</strong>的类作为预测结果。</p>
<p>每个类与特征的似然度是不同的，也就是 &#x3D;&#x3D;P(x<sub>i</sub>|y)&#x3D;&#x3D; 不同，因此<code>某一类别中某个特征的概率越大，就更容易对该类别进行分类</code>。根据求解后验概率的公式，可以得出以下优化方法：<br>$$<br>\large<br>y &#x3D; P(y)\prod\limits_{i &#x3D; 1}^nP(x_i|y)<br>$$<br>此时将<strong>后验概率</strong>记做类别 y，P(y) 是一个固定的概率值，因此要想让 y 取得最大值，只能通过 &#x3D;&#x3D;P(x<sub>i</sub>|y)&#x3D;&#x3D; 实现，不妨把被统计的数据看成是一张大表格，<strong>朴素贝叶斯算法</strong>就是从中找到 &#x3D;&#x3D;P(x<sub>i</sub>|y)&#x3D;&#x3D; 值最大的那一项，该项对应的 y 是什么，则最终输出的预测结果就是什么。</p>
<h3 id="12-4、sklearn应用朴素贝叶斯算法"><a href="#12-4、sklearn应用朴素贝叶斯算法" class="headerlink" title="12.4、sklearn应用朴素贝叶斯算法"></a>12.4、sklearn应用朴素贝叶斯算法</h3><p>在 sklearn 库中，基于贝叶斯定理的算法集中在 sklearn.naive_bayes 包中，根据对<strong>“似然度 P(xi|y)”</strong>计算方法的不同，我们将朴素贝叶斯大致分为三种：<code>多项式朴素贝叶斯（MultinomialNB）、伯努利分布朴素贝叶斯（BernoulliNB)、高斯分布朴素贝叶斯（GaussianNB）</code>。另外一点要牢记，朴素贝叶斯算法的实现是基于<strong>假设</strong>而来，在朴素贝叶斯看来，特征之间是相互独立的，互不影响的。</p>
<blockquote>
<p>高斯朴素贝叶斯适用于特征呈正态分布的，多项式贝叶斯适用于特征是多项式分布的，伯努利贝叶斯适用于二项分布。</p>
</blockquote>
<ol>
<li><p>算法使用流程</p>
<ul>
<li><p>统计样本数，即统计先验概率 <code>P(y)</code> 和 似然度 <code>P(x|y)</code>。</p>
</li>
<li><p>根据待测样本所包含的特征，对不同类分别进行<strong>后验概率</strong>计算。</p>
</li>
<li><p>比较 y1，y2，…yn 的后验概率，<code>哪个的概率值最大就将其作为预测输出</code>。</p>
</li>
</ul>
</li>
<li><p>朴素贝叶斯算法的应用</p>
<p>以鸢尾花数据集对朴素贝叶斯分类算法的应用为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 鸢尾花数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="comment"># 导入朴素贝叶斯模型，这里选用高斯分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;main&#x27;</span>:</span><br><span class="line">    <span class="comment"># 载入数据集</span></span><br><span class="line">    X, y = load_iris(return_X_y=<span class="literal">True</span>)</span><br><span class="line">    bayes_model = GaussianNB()</span><br><span class="line">    <span class="comment"># 训练数据</span></span><br><span class="line">    bayes_model.fit(X, y)</span><br><span class="line">    <span class="comment"># 使用模型进行分类预测</span></span><br><span class="line">    result = bayes_model.predict(X)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="comment"># 对模型评分</span></span><br><span class="line">    model_score = bayes_model.score(X, y)</span><br><span class="line">    <span class="built_in">print</span>(model_score)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="13、决策树算法"><a href="#13、决策树算法" class="headerlink" title="13、决策树算法"></a>13、决策树算法</h2><p>决策树算法算是一类算法，这类算法逻辑模型以<strong>“树形结构”</strong>呈现。</p>
<h3 id="13-1、if-else-原理"><a href="#13-1、if-else-原理" class="headerlink" title="13.1、if-else 原理"></a>13.1、if-else 原理</h3><p>是<strong>条件判断</strong>的常用语句，可以简单理解为“如果满足条件就….，否则…..”。</p>
<p>if-else 有两个特性：一是能够利用 if-else 进行条件判断，但需要首先给出判断条件；二是能无限嵌套，也就是在一个 if-else 的条件执行体中，能够再嵌套另外一个 if-else，从而实现无限循环嵌套。</p>
<h3 id="13-2、决策树算法关键"><a href="#13-2、决策树算法关键" class="headerlink" title="13.2、决策树算法关键"></a>13.2、决策树算法关键</h3><p>决策树算法涉及了几个重要的知识点：“决策树的分类方法”，“分支节点划分问题”以及“纯度的概念”，还会涉及到“信息熵”、“信息增益”、“基尼指数”的概念。</p>
<blockquote>
<p>特征维度&amp;判别条件</p>
</blockquote>
<p>分类问题的数据集由许多样本构成，而每个样本数据又会有多个<strong>特征维度</strong>，在决策算法中这些特征维度属于一个集合，称为“特征维度集”。数据样本的特征维度与最终样本的分类都可能存在着某种关联，因此决策树的<strong>判别条件</strong>将从特征维度集中产生。</p>
<h3 id="13-3、纯度"><a href="#13-3、纯度" class="headerlink" title="13.3、纯度"></a>13.3、纯度</h3><p>是对单一类样本在子集内所占重的的度量。</p>
<p>在每一次判别结束后，如果集合中归属于<code>同一类别的样本越多</code>，那么就说明这个<code>集合的纯度就越高</code>。比如，二元分类问题的数据集都会被分成两个子集，通过自己的纯度就可以判断分类效果的好与坏，<code>子集的纯度越高，就说明分类效果越好</code>。</p>
<p>决策树算法是一类算法，并非某一种算法，其中最著名的决策树算法有三种，分别是 <code>ID3、C4.5 和 CART</code>。在衡量<strong>“纯度”</strong>的方法上，它们分别采用了<code>信息增益、增益率和基尼指数</code>。</p>
<h4 id="13-3-1、纯度度量规则"><a href="#13-3-1、纯度度量规则" class="headerlink" title="13.3.1、纯度度量规则"></a>13.3.1、纯度度量规则</h4><p>度量“纯度”的规则（将类别分为“正类与负类”）：</p>
<ul>
<li>某个分支节点下所有样本都属于同一个类别，纯度达到最高值。</li>
<li>某个分支节点下样本所属的类别一半是正类一半是负类，此时，纯度取得最低值。</li>
<li>纯度代表一个类在子集中的占比多少，它并不在乎该类究竟是正类还是负类。比如，某个分支下不管是正类占比 60% 还是负类占比 60%，其纯度的度量值都是一样的。</li>
</ul>
<h4 id="13-3-2、纯度度量方法"><a href="#13-3-2、纯度度量方法" class="headerlink" title="13.3.2、纯度度量方法"></a>13.3.2、纯度度量方法</h4><ol>
<li><p>纯度函数</p>
<p>横轴表示某个类的占比，纵轴表示纯度值。</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E7%BA%AF%E5%BA%A6%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.gif" alt="纯度函数图像"></p>
<p>当在 a 点时某一类的占比纯度最小，但是对于二元分类来说，一个类小，另一个类就会高，因此 a 点时的纯度也最高（与 b 恰好相反），当某类的纯度占比在 c 点时，对于二元分类来说，两个类占比相同，此时的纯度值最低，此时通过 c 点无法判断一个子集的所属类别。</p>
</li>
<li><p>纯度度量函数</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E7%BA%AF%E5%BA%A6%E5%BA%A6%E9%87%8F%E5%87%BD%E6%95%B0.gif" alt="纯度度量函数"></p>
<p>纯度度量函数与纯度函数恰好相反，纯度度量函数图像适应于所有决策树算法，比如 ID3、C4.5、CART 等经典算法。</p>
</li>
</ol>
<h3 id="13-4、信息熵"><a href="#13-4、信息熵" class="headerlink" title="13.4、信息熵"></a>13.4、信息熵</h3><p>信息熵是用来解决对信息的量化问题的</p>
<blockquote>
<p>信息熵是用于衡量不确定性的指标，也就是离散随机事件出现的概率，简单地说“情况越混乱，信息熵就越大，反之则越小”。</p>
</blockquote>
<p>信息熵的计算公式:<br>$$<br>\large<br>H(x) &#x3D; -\sum\limits_{k&#x3D;1}^{N}P_klog_2(P_k)<br>$$<br>其中 p 代表概率的意思，这里 “X” 表示进行信息熵计算的集合。在决策树分类算法中，可以按各个类别的占比（占比越高，该类别纯度越高）来理解，其中 N 表示类别数目，而 Pk 表示类别 K 在子集中的占比。信息熵的计算过程分为三次四则运算，即相乘、求和最后取反。</p>
<h3 id="13-5、信息增益"><a href="#13-5、信息增益" class="headerlink" title="13.5、信息增益"></a>13.5、信息增益</h3><p>决策树算法是以包含所有<strong>类别的集合</strong>为计算对象，并通过条件判别，从中筛选出纯度较高的类别</p>
<p>以 ID3 算法为例，<strong>ID3</strong>（Iterative Dichotomiser 3，迭代二叉树3代）算法是决策树算法的其中一种，它是基于<strong>奥卡姆剃刀原理</strong>实现的，这个原理的核心思想就是“大道至简，用尽量少的东西去做更多的事情”。</p>
<p>ID3 算法的核心思想：越小型的决策树越优于大的决策树，也就是使用尽可能少的判别条件。</p>
<p>ID3 算法选择信息增益最大的特征维度进行 if-else 判别。</p>
<ol>
<li><p>理解信息增益</p>
<p>信息增益是针对一个具体的特征而言的，某个特征的有无对于整个系统、集合的影响程度就可以用“信息增益”来描述。</p>
<p>“纯度”最高的划分条件，也就是要找的<strong>“最合适”</strong>的特征维度判别条件。</p>
</li>
<li><p>信息增益公式</p>
<p>比较划分前后集合的信息熵来判断，也就是做减法，用划分前集合的信息熵减去按特征维度属性划分后的信息熵，就可能够得到信息增益值。公式如下所示：<br>$$<br>G(S,t) &#x3D; H(x) - \sum\limits_{k&#x3D;1}^{K}\frac{|S^k|}{|S|}H(S^k)<br>$$</p>
</li>
</ol>
<p>G(S,t) 表示集合 S 选择特征属性 t 来划分子集时的信息增益。H(x) 表示集合的信息熵。</p>
<p>   减数的含义：</p>
<ul>
<li><p>大写字母 K 表示：按特征维度 t 划分后，产生了几个子集的意思，比如划分后产生了 5 个子集吗，那么 K &#x3D; 5。</p>
</li>
<li><p>小写字母 k 表示：按特征维度 t 划分后，5 个子集中的某一个子集，k &#x3D; 1 指的是从第一个子集开始求和计算。</p>
<ul>
<li>|S| 与 |S<sub>k</sub>| 表示：集合 S 中元素的个数，这里的<code>||</code>并不是绝对值符号，而 |S<sub>k</sub>| 表示划分后，某个集合的元素个数。</li>
<li>|S|&#x2F;|S<sub>k</sub>| 表示：一个子集的元素个数在原集合的总元素个数中的占比，指该子集信息熵所占的权重，占比越大，权重就越高。</li>
</ul>
<p>最后，比较不同特征属性的信息增益，增益值越大，说明子集的纯度越高，分类的效果就越好，我们把效果最好的特征属性选为 if-else 的最佳判别条件。</p>
</li>
</ul>
<h3 id="13-6、决策树算法原理"><a href="#13-6、决策树算法原理" class="headerlink" title="13.6、决策树算法原理"></a>13.6、决策树算法原理</h3><p>决策树算法是一种<code>树形分类结构</code>，要通过这棵树实现样本分类，就要根据 <strong>if-else</strong> 原理设置判别条件。</p>
<p>决策树特征属性是 if-else 判别条件的关键所在，可以把这些特征属性看成一个<strong>集合</strong>，要选择的判别条件都来自于这个集合，通过分析与计算选择与待分类样本最合适的<strong>“判别条件”</strong>。被选择的<strong>“判别条件”</strong>使得样本集合的某个子树节点<strong>“纯度”</strong>最高。</p>
<p>上述过程就好比从众多的样本中提取<strong>“类别纯度”</strong>最高的样本集合，因此可以起一个形象化的名字<strong>“提纯”</strong>，过程示意图如下所示：</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/1I6033T7-0.gif" alt="决策树流程图"></p>
<p>决策树算法通过判别条件从根节点开始分裂为子节点，子节点可以继续分裂，每一次分裂都相当于一次对分类结果的<strong>“提纯”</strong>，周而复始，从而达到分类的目的，在这个过程中，节点为“否”的不在分裂，判断为“是”的节点则继续分裂。</p>
<p>决策树停止分类的条件：</p>
<ol>
<li><p>子节点属于同一类别</p>
<p>决策树算法的目的是为了完成有效的样本分类。当某个数据集集合分类完成，也就分类后的子节点集合都属于同一个类别，不可再分，此时代表着分类任务完成，分裂也就会终止。</p>
</li>
<li><p>特征属性用完</p>
<p>决策树依赖<strong>特征属性</strong>作为判别条件，如果特征属性已经全部用上，自然也就无法继续进行节点分裂，此处可能就会出现两种情况：一种是分类任务完成，也就是子节点属于同一类别，还有另外一种情况就是分类还没有完成，比如，在判断为“是”的节点集合中，有 8 个正类 3 个负类，此时我们将采用<strong>占比最大的类</strong>作为当前节点的归属类。</p>
</li>
<li><p>设置停止条件</p>
<p>可以在外部设置一些阈值，把决策树的深度，或者叶子节点的个数当做停止条件。</p>
</li>
</ol>
<h3 id="13-7、决策树剪枝策略"><a href="#13-7、决策树剪枝策略" class="headerlink" title="13.7、决策树剪枝策略"></a>13.7、决策树剪枝策略</h3><p>决策树分类算法最容易出现的问题就是“过拟合”。</p>
<blockquote>
<p>“过拟合”使决策树模型学习到了并不具备普遍意义的分类决策条件，从而导致模型的分类效率、泛化能力降低。</p>
</blockquote>
<p>“剪枝策略”是解决决策树算法过拟合问题的核心方法，也是决策树算法的重要组成部分。据剪枝操作触发时间的不同，可以将它们分成两种，一种称为<strong>预剪枝</strong>，另一种称为<strong>后剪枝</strong>。</p>
<ol>
<li><p>预剪枝</p>
<p>在<code>分支划分之前</code>就进行剪枝判断，如果判断结果是需要剪枝，则不进行该分支划分。</p>
</li>
<li><p>后剪枝</p>
<p>在<code>分支划分之后</code>，通常是决策树的各个判断分支已经形成后，才开始进行剪枝判断。</p>
</li>
</ol>
<p>在实际情况中<strong>后剪枝策略</strong>使用较多。在分支生成后，使用后剪枝策略将冗余的子树及其判别条件直接剪掉，然后使用上个节点中占比最大的类做为最终的分类结果。</p>
<h3 id="13-8、sklearn决策树算法分类"><a href="#13-8、sklearn决策树算法分类" class="headerlink" title="13.8、sklearn决策树算法分类"></a>13.8、sklearn决策树算法分类</h3><ol>
<li><p>.DecisionTreeClassifier()</p>
<p>这是一个经典的决策树分类算法，它提供了许多有用的参数，比如 <code>criterion</code>，该参数有两个参数值，分别是 <code>gini（基尼指数）</code>和 <code>entropy（信息增益）</code>，默认情况下使用<strong>“基尼指数”</strong>，其中<strong>“gini”</strong>用于创建 CART 分类决策树，而<strong>“entropy”</strong>用于创建 ID3 分类决策树。</p>
<blockquote>
<p>注意：在其余三个决策树算法中都可以使用 criterion 参数。</p>
</blockquote>
</li>
<li><p>.DecisionTreeRegressor()</p>
<p>它表示用决策树算法解决回归问题。</p>
</li>
<li><p>.ExtraTreeClassifier()</p>
<p>该算法属于决策树分类算法，但又不同于<code>.DecisionTreeClassifier()</code>算法，因为<code>.ExtraTreeClassifier()</code>选择“特征维度”作为判别条件时具有随机性，它首先从特征集合中随机抽取 n 个特征维度来构建新的集合，然后再从新的集合中选取“判别条件”。</p>
</li>
<li><p>.ExtraTreeRegressor()</p>
<p>该算法同样具有随机性，它与<code>.ExtraTreeClassifier()</code>随机过程类似，它主要解决机器学习中的回归问题。</p>
</li>
</ol>
<h3 id="13-9、决策树实现步骤"><a href="#13-9、决策树实现步骤" class="headerlink" title="13.9、决策树实现步骤"></a>13.9、决策树实现步骤</h3><p>决策树分类算法的关键在于选择合适的<strong>“判别条件”</strong>，该判别条件会使正确的分类的样本<strong>“纯度”</strong>最高。想要选取合适的特征属性就需要使用<strong>“信息熵”</strong>与<strong>“信息增益”</strong>等计算公式。</p>
<ol>
<li><p>确定纯度指标</p>
<p>用来衡量不同<strong>“特征属性”</strong>所得到的纯度，并选取使得纯度取得<strong>最大值</strong>的“<strong>特征属性”</strong>作为<strong>“判别条件”</strong>。</p>
</li>
<li><p>切分数据集</p>
<p>通过特征属性做为<strong>“判别条件”</strong>对数据集集合进行切分。注意，使用过的<strong>“特征属性”</strong>不允许重复使用，该属性会从特征集合中<strong>删除</strong>。</p>
</li>
<li><p>获取正确分类</p>
<p>选择特征集合内的特征属性，直至没有属性可供选择，或者是数据集样本已经完成分类为止。切记要选择<code>占比最大的类别做为分类结果</code>。</p>
</li>
</ol>
<h3 id="13-10、决策树算法的应用"><a href="#13-10、决策树算法的应用" class="headerlink" title="13.10、决策树算法的应用"></a>13.10、决策树算法的应用</h3><p>下面使用决策树算法对 Sklearn 库中的红酒数据进行模型训练，与数据预测，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载红酒数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="comment"># 导入决策树分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="comment"># 导入分割数据集的方法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 导入科学计算包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 加载红酒数据集</span></span><br><span class="line">    wine_dataset = load_wine()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分割训练集与测试集</span></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(wine_dataset[<span class="string">&#x27;data&#x27;</span>], wine_dataset[<span class="string">&#x27;target&#x27;</span>], test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                        random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建决策时分类器--ID3算法</span></span><br><span class="line">    tree_model = DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    <span class="comment"># 喂入数据</span></span><br><span class="line">    tree_model.fit(X_train, y_train)</span><br><span class="line">    <span class="comment"># 打印模型评分</span></span><br><span class="line">    <span class="built_in">print</span>(tree_model.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给出一组数据预测分类</span></span><br><span class="line">    X_wine_test = np.array([[<span class="number">11.8</span>, <span class="number">4.39</span>, <span class="number">2.39</span>, <span class="number">29</span>, <span class="number">82</span>, <span class="number">2.86</span>, <span class="number">3.53</span>, <span class="number">0.21</span>, <span class="number">2.85</span>, <span class="number">2.8</span>, <span class="number">.75</span>, <span class="number">3.78</span>, <span class="number">490</span>]])</span><br><span class="line">    predict_result = tree_model.predict(X_wine_test)</span><br><span class="line">    <span class="built_in">print</span>(predict_result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分类结果：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(wine_dataset[<span class="string">&#x27;target_names&#x27;</span>][predict_result]))</span><br></pre></td></tr></table></figure>

<h2 id="14、支持向量机-SVM-分类算法"><a href="#14、支持向量机-SVM-分类算法" class="headerlink" title="14、支持向量机 SVM 分类算法"></a>14、支持向量机 SVM 分类算法</h2><p>支持向量机，英文全称“Support Vector Machines”（简称 SVM），是有监督学习中最有影响力的机器学习算法之一。</p>
<h3 id="14-1、支持向量机组成"><a href="#14-1、支持向量机组成" class="headerlink" title="14.1、支持向量机组成"></a>14.1、支持向量机组成</h3><p>支持向量机是一个分类器算法，主要用于解决二分类的问题，有三个重要构件，分别是：</p>
<ul>
<li>最大间隔</li>
<li>高维映射</li>
<li>核函数</li>
</ul>
<h3 id="14-2、支持向量机本质"><a href="#14-2、支持向量机本质" class="headerlink" title="14.2、支持向量机本质"></a>14.2、支持向量机本质</h3><p>支持向量机本质上是从在<strong>线性分类算法</strong>的基础上发展而来的，就如同 Logistic 逻辑回归算法一样，只需给线性函数“套”上一层 Logistic “马甲”，就可以用线性模型来解决离散数据的分类问题。</p>
<ol>
<li><p>间隔和支持向量</p>
<p>支持向量机中有一个非常重要的概念就是“间隔最大化”，它是衡量 SVM 分类结果是否最优的标准之一。</p>
<p>以“象棋”的例子来理解什么是“间隔”：</p>
<p>中国象棋的棋子分为黑子和红子，并用“楚河汉界”将其分开。如果用一条直线将不同颜色的棋子进行分类，这显然信手拈来，只需要在楚河汉界的空白附带画一条“中轴线”就能以最佳的方式将它们分开，这样就能保证两边距离最近的棋子保有充分的“间隔”。</p>
<p>上述示例中产生的<strong>“间隔”</strong>实际上是依据两侧不同颜色的棋子划分而成的，我们把这些棋子统称为<strong>“样本点”</strong>。虽然这些样本点都参与了分类，但对于分类效果影响最大的是处于间隔<strong>“边缘”</strong>的样本，只要将处于边缘的样本正确分类，那么这两个类别也就分开了，因此我们把处于边缘样本点称为<strong>“支持向量”</strong>。</p>
</li>
<li><p>软件隔和硬间隔</p>
<p>当使用直线分类时会本着尽可能将类别全都区分开来的原则，但总存在一些<code>另类的“样本点”不能被正确的分类</code>，如果允许这样的“样本点存在”，那么画出的间隔就成为<strong>“软间隔”</strong>，反之态度强硬必须要求“你是你，我是我”，这种间隔就被称为<strong>“硬间隔”</strong>，在处理实际业务中，硬间隔只是一种理想状态。</p>
</li>
<li><p>最大间隔</p>
<p>上述所说的保有充分的“间隔”，其实就是<strong>“最大间隔”</strong>，如果将数据样本分割的不留余地，就会对随机扰动的噪点特别敏感，这样就很容易破坏掉之前的分类结果，学术称为<code>“鲁棒性差”</code>，因此我们在分类时要尽可能使<code>正负两类分割距离达到最大间隔</code>。</p>
</li>
</ol>
<h3 id="14-3、SVM-高维映射"><a href="#14-3、SVM-高维映射" class="headerlink" title="14.3、SVM 高维映射"></a>14.3、SVM 高维映射</h3><p>高维映射主要是用来解决“你中我，我中有你”的分类问题的，也就是“线性不可分问题”，所谓高维映射就是<code>站在更高的维度来解决低维度的问题</code>。</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/142642C19-0.gif" alt="超平面"></p>
<p>如图所示经过高维映射后，二维分布的样本点就变成了三维分布，而那张恰好分开样本点的面（绿色的平面）， SVM 统称其为<strong>“超平面”</strong>。</p>
<p>通过增加一个维度的方法（给平面增加一个高度，使其变成三维空间），解决“线性不可分的问题”。</p>
<h3 id="14-4、SVM-核函数"><a href="#14-4、SVM-核函数" class="headerlink" title="14.4、SVM 核函数"></a>14.4、SVM 核函数</h3><p>核函数是一类功能性函数，类似于 Logistic 函数。SVM 规定，<code>只要能够完成高维映射功能的数学函数都称为“核函数”</code>，它在支持向量机中承担着两项任务，一是<code>增加空间的维度</code>，二是<code>完成现有数据从原空间到高维空间的映射</code>。</p>
<h3 id="14-5、SVM-算法总结"><a href="#14-5、SVM-算法总结" class="headerlink" title="14.5、SVM 算法总结"></a>14.5、SVM 算法总结</h3><p>SVM 算法是用来解决线性不可分的<strong>“非线性”</strong>问题， 从而突破线性分类的局限性，使得线性分类器依然可以适用于“非线性”问题。在这个过程中起到关键作用的就是<strong>“高维映射”</strong>。而<strong>“间隔最大化”</strong>可以看做支持向量机的<strong>损失函数</strong>，它衡量分类效果是否最佳的“标尺”，让间隔达到最大就是 SVM 追求的至臻境界，要实现这个目标就要不断地训练模型，使模型的泛化能力最佳。</p>
<p>最后对 SVM 算法进行分类的大致过程进行总结，大致分为以下三步：</p>
<ul>
<li>选取一个合适的数学函数作为<strong>核函数</strong>；</li>
<li>使用<code>核函数进行高维映射</code>，解决样本点线性不可分的问题；</li>
<li>最后用<strong>间隔</strong>作为度量分类效果的<strong>损失函数</strong>，找到使间隔最大的<code>超平面</code>，最终完成分类的任务。</li>
</ul>
<h3 id="14-6、SVM-算法应用"><a href="#14-6、SVM-算法应用" class="headerlink" title="14.6、SVM 算法应用"></a>14.6、SVM 算法应用</h3><p>Sklearn 库中的 SVM 算法如下所示：</p>
<table>
<thead>
<tr>
<th>SVM算法类别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LinearSVC类</td>
<td>基于线性核函数的支持向量机分类算法</td>
</tr>
<tr>
<td>LinearSVR类</td>
<td>基于线性核函数的支持向量机回归算法</td>
</tr>
<tr>
<td>SVC类</td>
<td>可选择多种核函数的支持向量机分类算法，通过“kernel”参数可以传入 <br>linear：选择线性函数；<br>polynomial：选择多项式函数；<br>rbf：选择径向基函数；<br>sigmoid：选择 Logistics 函数作为核函数；<br>precomputed：使用预设核值矩阵；<br>SVC 类默认以径向基函数作为核函数</td>
</tr>
<tr>
<td>SVR类</td>
<td>可选择多种核函数的支持向量机回归算法</td>
</tr>
<tr>
<td>NuSVC类</td>
<td>与 SVC 类非常相似，但可通过参数“nu”设置支持向量的数量</td>
</tr>
<tr>
<td>NuSVR类</td>
<td>与SVR类非常相似，但可通过参数“nu”设置支持向量的数量</td>
</tr>
<tr>
<td>OneClassSVM类</td>
<td>用支持向量机算法解决无监督学习的异常点检测问题</td>
</tr>
</tbody></table>
<p>SVM 主要用于解决二分类的问题，上述表格中最常使用的是 SVC 类。下面对使用该算法的步骤进行总结：</p>
<ul>
<li>读取数据，将原始数据<strong>转化</strong>为 SVM 算法所能识别的数据格式；</li>
<li>将<strong>数据标准化</strong>，防止样本中不同特征数值大小相差较大影响分类器性能；</li>
<li>选择<strong>核函数</strong>，在不清楚何种核函数最佳时，推荐使用“rbf”（径向基核函数）</li>
<li>利用<code>交叉验证网格搜索寻找最优参数</code>；（交叉验证的目的是防止过拟合，利用网格搜索可以在指定的范围内寻找最优参数）</li>
<li>使用最优参数来训练模型；</li>
<li>测试得到的分类模型。</li>
</ul>
<p>使用支持向量机（SVM）算法对鸢尾花数据集进行分类，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris  <span class="comment"># 导入鸢尾花数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC  <span class="comment"># 使用支持向量机算法</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 加载鸢尾花数据集，返回特征值 X 以及标签 y</span></span><br><span class="line">    X, y = load_iris(return_X_y=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 使用SVM.SVC分类算法搭建预测模型，并以径向基函数做为核函数的实现高维映射</span></span><br><span class="line">    clf = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>)</span><br><span class="line">    <span class="comment"># 训练模型,使用fit喂入数据X,y，即特征值和标签</span></span><br><span class="line">    clf.fit(X, y)</span><br><span class="line">    <span class="comment"># 预测分类</span></span><br><span class="line">    result = clf.predict(X)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="comment"># 对模型进行评分</span></span><br><span class="line">    score = clf.score(X, y)</span><br><span class="line">    <span class="built_in">print</span>(score)</span><br><span class="line">    plt.figure()</span><br><span class="line">    <span class="comment"># 分割图1行1列第一个图</span></span><br><span class="line">    plt.subplot(<span class="number">111</span>)</span><br><span class="line">    <span class="comment"># 选择X特征值中的第一列特征值和第三列特征值进行绘图</span></span><br><span class="line">    plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">3</span>], c=y.reshape((-<span class="number">1</span>)), edgecolor=<span class="string">&#x27;k&#x27;</span>, s=<span class="number">50</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p>支持向量机算法在<strong>分类问题</strong>中有着非常出色的表现，它的特点是<code>能够解决非线性问题，并且训练模型的时候不必依赖于全部数据，主要使用处于分类边缘的样本点</code>，因此它也<code>适用解决小样本群体的分类问题，并且泛化能力较强</code>。</p>
<p>当然，SVM 也有一些不足之处，比如核函数的寻找难度较大，并且最原始的 SVM 算法只适用于二分类问题。后经过不断的拓展、延伸，<code>目前的 SVM 算法可以解决多分类问题，同时能够解决文本分类问题</code>。</p>
<h2 id="15、K-means-聚类算法"><a href="#15、K-means-聚类算法" class="headerlink" title="15、K-means 聚类算法"></a>15、K-means 聚类算法</h2><p>常见的无监督学习算法，包括 <strong>K-means 聚类算法</strong>、均值漂移聚类算法、主成分分析法（即 PCA 算法）、EM算法（期望最大化算法）等。</p>
<p>无监督学习中最为经典的是 K-means 算法，它是聚类算法簇中的一个，也是最为经典的聚类算法，其原理简单、容易理解，因此得到广泛的应用。</p>
<h3 id="15-1、聚类和分类的区别"><a href="#15-1、聚类和分类的区别" class="headerlink" title="15.1、聚类和分类的区别"></a>15.1、聚类和分类的区别</h3><p>聚类算法与分类算法的最终的目的都是<strong>将数据区分开来</strong>，但是两者的实现过程完全不同。</p>
<p>分类问题：通过对<code>已有标签</code>的数据进行训练来确定最佳预测模型，然后对新样本的所属类别进行预测，在这个过程中算法模型只要尽可能的实现最佳拟合就 OK 了。</p>
<p>聚类问题：对没有任何标签的数据，通过”找相似“来实现分类，既在实现分类时，只能尽可能找相同点，相同点越多，说明他们就属于同一类，而不同点越多，就说明两者不是同一类。</p>
<h3 id="15-2、簇"><a href="#15-2、簇" class="headerlink" title="15.2、簇"></a>15.2、簇</h3><p>在聚类问题中，有一个非常重要的概念<strong>“簇”（Cluster）</strong>，那到底什么是簇呢，样本数据集通过聚类算法最终会聚集成一个个“类”，这些类在机器学习中的术语称为“簇”（<strong>注意，这里的前提是使用“聚类算法”</strong>），因此“簇”是解决聚类问题的表现形式，数据集中的数据样本最终会以“簇”的形式分开。</p>
<p>对于解决一个聚类问题，到底要汇集成多少簇，不同聚类算法采取了不同的思路，主要分为<strong>划分法、层次法、密度法和网格法</strong>，这些方法大致可总结为两类，<code>一类是预先设定有多少个簇，另一类则是在聚类的过程中形成</code>。</p>
<h3 id="15-3、K-means-聚类算法中-K-的含义"><a href="#15-3、K-means-聚类算法中-K-的含义" class="headerlink" title="15.3、K-means 聚类算法中 K 的含义"></a>15.3、K-means 聚类算法中 K 的含义</h3><p>K-means 就是一种采用了划分法的聚类算法，由于该算法是没有参考标准的。如果不加以限定的话，它会形多任意数量的“簇”，这就要求在使用该算法时要预先设定“簇”的数量，就像田忌赛马一样，根据马的自身的特点，将其分为上、中、下三个档次，因此 <code>K-means 中 K 是聚集成几个“簇”，形成几个“类”的意思</code>。</p>
<h3 id="15-4、量化相似"><a href="#15-4、量化相似" class="headerlink" title="15.4、量化相似"></a>15.4、量化相似</h3><blockquote>
<p>注意，这里所说的“相似”有时也称之为“相似度”与之含义相反的是“相异度”，相异度越低，相似度就越高，这些词语主用于是衡量对象之间的相似程度。</p>
</blockquote>
<ol>
<li><p>随机选择质心<br>解决 K-means 聚类问题，需要一个“中心点”，假设聚类问题的样本数据能够找出 K 个中心点，就能<code>以该点为中心，以距离为度量画出范围来，将同一范围内的样本点作为一个簇</code>，从而解决聚类问题，在 K-means 聚类算法中，这样的中心点称为“质心”。</p>
<p>聚类算法是无监督学习，因此数据中的样本点完全不知道自己属于哪一个簇，就更别谈确定“质心”了，为了解决这一问题，K-means 算法通过<strong>随机选择</strong>方式来确定质心，但由于是随机选择，因此无法保证随机选择的 K 个质心就恰好是完成聚类后的 K 个簇的中心点，这时就用到了<strong>“mean”</strong>，它是<strong>“均值”</strong>的意思，通过均值可以不断的调整质心，由此可知<code>质心在 K-means 算法中是不断改变的</code>。</p>
</li>
<li><p>求出新质心点<br>假设现在随机了 K 个质心得到了 K 个簇，K-means 算法选择<strong>求平均</strong>，让这 K 个簇形成新的质心。每个簇都有若干数据点，求出这些数据点的<strong>坐标值均值</strong>，就得到了新质心的坐标点。这其实也是一种变相的多数表决。根据全体拥有表决权的数据点的坐标来共同决定新的质心在哪里，而表决权则由簇决定。<br>在 K-means 聚类的过程中会经历<code>多次质心计算</code>，数据点到底归属于哪个簇可能会频繁变动，比如同一个数据点可能在本轮与一群样本点进行簇 A 的质心计算，而在下一轮就与另一群样本点进行簇 B 的质心计算。</p>
</li>
</ol>
<h3 id="15-5、算法总结"><a href="#15-5、算法总结" class="headerlink" title="15.5、算法总结"></a>15.5、算法总结</h3><p>K-means 聚类算法的聚类过程，可以看成是<code>不断寻找簇的质心的过程，这个过程从随机设定 K 个质心开始，直到找到 K 个真正质心为止</code>。</p>
<p>K-means 聚类算法的大致过程如下所示：</p>
<ul>
<li>第一步，既然现在有了 K 个质心，对于其他数据点来说，根据其<code>距离哪个质心近</code>就归为哪个簇的办法，可以聚成 K 个簇。但请注意，这只是第一步，并不是最后完成聚类的结果；</li>
<li>第二步，对于聚成的 K 个簇，需要<code>重新选取质心</code>。这里运用了<code>多数表决原则</code>，根据一个簇内所有样本点各自的维度值来<strong>求均值</strong>，得到该簇的新的坐标值；</li>
<li>第三步是生成新的质心，其实就是重复上述过程。对于根据均值计算得到的 K 个新质心，重复第一步中离哪个质心近就归为哪个簇的过程，再次将全部样本点聚成 K 个簇，经过不断重复，<code>当质心不再变化后，就完成了聚类</code>。</li>
</ul>
<p>最后总结：K-means 算法首先<code>逐个计算数据集中的点到各自质心的距离</code>，根据距离的远近，将数据样本点分别划归到距离最近的质心，从而形成 K 个类，然后继续选取新的质心，即对聚类内所有数据点求均值。最后重复上述两个过程：生成新质心后重新进行聚类，然后根据聚类结果再次生成新的质心，直至划分的“类”不再变化时结束。</p>
<h3 id="15-6、K-means-聚类算法原理解析"><a href="#15-6、K-means-聚类算法原理解析" class="headerlink" title="15.6、K-means 聚类算法原理解析"></a>15.6、K-means 聚类算法原理解析</h3><h4 id="15-6-1、度量最小距离"><a href="#15-6-1、度量最小距离" class="headerlink" title="15.6.1、度量最小距离"></a>15.6.1、度量最小距离</h4><p>对于 K-means 聚类算法而言，找到质心是一项既核心又重要的任务，找到质心才可以划分出距离质心最近样本点。从数学角度来讲就是<font color="orange">让簇内样本点到达各自质心的距离总和最小</font>。</p>
<p>通过数学定义，将“质心”具象化，既然要使“<strong>距离的总和最小</strong>”，那么第一步就是确定如何度量距离，K-means 算法通过『<strong>欧几里得距离</strong>』来衡量质心与样本点之间的距离。如下所示：<br>$$<br>\large<br>d(x,y) &#x3D; \sqrt{\sum\limits_{i&#x3D;1}^n(x_i - y_i)^2}<br>$$<br>如果第 j 个簇内有若干个数据点（比如 m 个），根据上述欧几里得距离公式就可以计算出簇中各个点到质心<code>z</code>的距离总和，如下所示：<br>$$<br>\large<br>\sum\limits_{i&#x3D;0}^n(||x_i - z_j||^2)<br>$$</p>
<blockquote>
<p>注意，上述公式中的z<sub>j</sub>是簇内所有样本点求均值的结果</p>
</blockquote>
<p>K-measn 算法中会有 K 个簇，因此就要<code>使每个簇内的数据点到质心的距离都可以达到最小，最终使得距离的总和最小</code>。可以这样理解，K 个簇共同组成了一个集合（这里定义为 A 集合），在 A 集合中每个簇的样本点到各自质心的距离都是最小的，因此可得如下表达式：<br>$$<br>\large<br>\sum\limits_{i&#x3D;0}^n\mathop{min}\limits_{z_j \epsilon {A}}(||x_i - z_j||^2)<br>$$</p>
<h4 id="15-6-2、总结"><a href="#15-6-2、总结" class="headerlink" title="15.6.2、总结"></a>15.6.2、总结</h4><p>K-means 算法的流程回顾，可分以下四步：</p>
<ul>
<li>随机选取 K 个对象，并以它们为质心；</li>
<li>计算数据集样本点到质心的距离；</li>
<li>根据样本点距离质心的距离将其分簇（类），距离哪个近，划分到哪个簇（类）；</li>
<li>以簇内所有样本点的均值重新计算质心，，然后重复第二步，直到划分的簇（类）不在变化后停止。<br>K-means 算法是属于无监督学习算法，常用于解决聚类问题，通过给算法模型输入一个包含多种特征信息的样本点，会返回一个相应的类别编号（或称簇别），从而完成样本数据点的类别划分。</li>
</ul>
<p>注意，判定聚类任务完成的终止条件并不是唯一的，常用方法有三个：</p>
<ul>
<li>簇内数据点向质心靠拢、收敛，使得质心点不再发生明显的变化；</li>
<li>使用<a target="_blank" rel="noopener" href="http://误差平方和/">误差平方和</a>（即 SSE）来衡量，当误差平和的值越小时，表示数据点越接近于他们的质心，聚类效果越好；</li>
<li>设定指定的定迭代次数，即最多选取几次质心点，不过这种方法，未必能达到最好的分类效果。</li>
</ul>
<h3 id="15-7、Sklearn使用K-means算法"><a href="#15-7、Sklearn使用K-means算法" class="headerlink" title="15.7、Sklearn使用K-means算法"></a>15.7、Sklearn使用K-means算法</h3><p>K-means 算法适合于解决而特征维度为数值型的聚类问题，也适用于文本聚类，比如新闻网站会将相同话题的新闻聚集在一起，并自动生成一个个不同话题的新闻专栏，其实这就是利用聚类算法实现的，但是文本的特征维度并非数值类型，因此需要对其进行数值转化操作，将文本数据转换为数学信息，此时可以使用 TF-IDF 加权技术计算单个词的权值。</p>
<blockquote>
<p>TF-IDF 是一种用于信息检索与数据挖掘的常用加权技术。TF 是词频（Term Frequency），IDF 是逆文本频率指数（Inverse Document Frequency）。</p>
</blockquote>
<p>下表对 K-means 聚类算法的特点做了简单说明：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>原理简单，实现容易，运算效率高。</td>
</tr>
<tr>
<td>不足</td>
<td>需要人为设置簇的个数与随机初始化质心点可能影响聚类的最终效果，同时 K-measn 算法对孤立点（离群点）特别敏感，会对最终的聚类结果产生明显扰动。</td>
</tr>
<tr>
<td>应用领域</td>
<td>适用于特征维度为数据类型的聚类问题，比如体育赛事等，而对特征维度不是数据类型的需要提前进行转换，比如文本分类等。</td>
</tr>
</tbody></table>
<p>在 Sklearn 机器学习库中，与聚类相关的算法模型都在 cluster 模块下，除 k-measn 外，还有十种聚类最近邻算法，下表对最常用的算法做了简单介绍：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>KMeans 类</td>
<td>本节介绍的算法，也是应用最多的聚类算法</td>
</tr>
<tr>
<td>MiniBatchKMeans 类</td>
<td>该算法是 K-measn算法变形算法，使用 mini-batch（一种采样数据的思想） 来减少一次聚类所需的计算时间，mini-batch 也是深度学习常使用的方法。</td>
</tr>
<tr>
<td>DBSCAN 类</td>
<td>DBNSCAN 算法是一种比较有代表性的基于密度的聚类算法，它的主要思想是将聚类的类视为被低密度区域分割的高密度区域。与划分聚类方法不同，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的区域划分为簇。</td>
</tr>
<tr>
<td>MeanShift 类</td>
<td>MeanShift 算法流程，以任意点作为质心的起点，根据距离均值将质心不断往高密度的地方移动，也即所谓均值漂移，当不满足漂移条件后说明密度已经达到最高，就可以划分成簇。</td>
</tr>
<tr>
<td>AffinityPropagation 类</td>
<td>AffinityPropagation 算法（简称 AP 算法），该算法是层次聚类的典型应用，聚类实现过程是一个“不断合并同类项”的过程，用类似于归纳法思想来完成聚类。</td>
</tr>
<tr>
<td>通过表格不难看出，每一种算法所采用的思想均不相同，但最终都能解决聚类问题，这也是整个聚类算法族的特点之一。</td>
<td></td>
</tr>
</tbody></table>
<p>下面我们对<code>Kmeans.Kmeans()</code>的常用参数做简单介绍：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>algorithm</td>
<td>字符串参数值，有三种选择： 1) “auto” ：默认值，自动根据数据值是否稀疏，来决定使用 “full”还是”elkan”，采用默认值即可； 2) “full”：表示使用传统的 K-measn 算法； 3) “elkan”：表示使用 elkan-Means 算法，该算法可以减少不必要的距离计算，加快计算效率。</td>
</tr>
<tr>
<td>n_cluster</td>
<td>整型参数，表示分类簇的数量，默认值为 8</td>
</tr>
<tr>
<td>max_iter</td>
<td>整型参数，表示最大的迭代次数，默认值为 300</td>
</tr>
<tr>
<td>n_init</td>
<td>整型参数，表示用不同的质心初始化值运行算法的次数，默认值为 10</td>
</tr>
<tr>
<td>init</td>
<td>字符串参数，有三个可选参数： 1)” k-means++” ，默认值，用一种特殊的方法选定初始质心从而能加速迭代过程的收敛，效果最好； 2) “random” 表示从数据中随机选择 K 个样本作为初始质心点； 3) 提供一个 ndarray 数组，形如 (n_cluster,n_features)，以该数组作为初始质心点。</td>
</tr>
<tr>
<td>precompute_distance</td>
<td>有三个可选值，分别是 “auto”, True, False： 1) “auto” ：如果样本数乘以聚类数大于 12 million 的话则不予计算距离； 2) True：总是预先计算距离； 3) False：永远不预先计算距离。</td>
</tr>
<tr>
<td>tol</td>
<td>浮点型参数(float)，表示算法收敛的阈值，默认值为 1e-4</td>
</tr>
<tr>
<td>n_jobs</td>
<td>整型参数，指定计算所用的进程数量， 1) 若值为 -1，则用所有 CPU 进行运算； 2) 若值为 1 ，则不进行并行运算，方便调试； 3) 若值小于 -1，则用到的 CPU 数为(n_cpus+1+n_jobs)，因此若为 -2 ，则用到的 CPU 数为总 CPU 数减去1</td>
</tr>
<tr>
<td>random_state</td>
<td>表示随机数生成器的种子，参数值为整形或 numpy.RandomState 类型</td>
</tr>
<tr>
<td>verbose</td>
<td>整型参数，默认值为 0，表示不输出日志信息；1 表示每隔一段时间打印一次日志信息；如果大于 1时，打印次数变得频繁。</td>
</tr>
</tbody></table>
<p>最后通过鸢尾花数据集对 K-means 算法进行简单的演示，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 设置 matplotlib rc配置文件</span></span><br><span class="line">    matplotlib.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">u&#x27;SimHei&#x27;</span>]  <span class="comment"># 用来设置字体样式以正常显示中文标签</span></span><br><span class="line">    matplotlib.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 设置为 Fasle 来解决负号的乱码问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载鸢尾花数据集</span></span><br><span class="line">    <span class="comment"># 数据的特征分别是 sepal length(花萼长度)、sepal width(花萼宽度)、petal length（花瓣长度）、petal width（花瓣宽度）</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    X = iris.data[:, :<span class="number">2</span>]  <span class="comment"># 通过花萼的两个特征（长度和宽度）来聚类</span></span><br><span class="line">    k = <span class="number">3</span>  <span class="comment"># 假设聚类为 3 类，默认分为 8 个 簇</span></span><br><span class="line">    <span class="comment"># 构建算法模型</span></span><br><span class="line">    km = KMeans(n_clusters=k)  <span class="comment"># n_clusters参数表示分成几个簇（此处k=3）</span></span><br><span class="line">    km.fit(X)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取聚类后样本所属簇的对应编号（label_pred）</span></span><br><span class="line">    label_pred = km.labels_  <span class="comment"># labels_属性表示每个点的分簇号，会得到一个关于簇编号的数组</span></span><br><span class="line">    centroids = km.cluster_centers_  <span class="comment"># cluster_center 属性用来获取簇的质心点，得到一个关于质心的二维数组，形如[[x1,y1],[x2,y2],[x3,x3]]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 未聚类前的数据分布图</span></span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], s=<span class="number">50</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;花萼长度&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;花萼宽度&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;未聚类之前&quot;</span>)</span><br><span class="line">    <span class="comment"># wspace 两个子图之间保留的空间宽度</span></span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.5</span>)  <span class="comment"># subplots_adjust（）用于调整边距和子图间距</span></span><br><span class="line">    <span class="comment"># 聚类后的分布图</span></span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    <span class="comment"># c：表示颜色和色彩序列，此处与 cmap 颜色映射一起使用（cool是颜色映射值）s表示散点的的大小，marker表示标记样式（散点样式）</span></span><br><span class="line">    plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=label_pred, s=<span class="number">50</span>, cmap=<span class="string">&#x27;cool&#x27;</span>)</span><br><span class="line">    <span class="comment"># 绘制质心点</span></span><br><span class="line">    plt.scatter(centroids[:, <span class="number">0</span>], centroids[:, <span class="number">1</span>], c=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;花萼长度&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;花萼宽度&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;K-Means算法聚类结果&quot;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="16、神经网络分类算法"><a href="#16、神经网络分类算法" class="headerlink" title="16、神经网络分类算法"></a>16、神经网络分类算法</h2><p><strong>深度学习（Deep Learning）</strong>这一概念是由 Geoffrey Hinton（深度学习之父）于 2006 年提出，但它的起源时间要早得多，可追溯至 20 世纪四五十年代，也就是人类刚刚发明出电子计算机时就已经提出来了，但当时并非叫做深度学习，而是人工神经网络（artificial neural network, ANN），简称神经网络（NN），它是一种算法模型，其算法的构思灵感来源于生物神经网络。</p>
<h3 id="16-1、MP神经元模型"><a href="#16-1、MP神经元模型" class="headerlink" title="16.1、MP神经元模型"></a>16.1、MP神经元模型</h3><p>人工神经网络是一种<code>有监督学习算法</code>，它试图通过模拟人脑神经系统对复杂信息的处理机制来构建一种数学模型。我们知道，神经元是构成生物神经系统的基本单元，而人工神经网络也不例外，它也是从<strong>神经元模型</strong>的基础上发展而来的。</p>
<p>1943 年，美国心理学家麦克洛奇（Mcculloch）和数学家皮兹（Pitts）提出了 M-P 神经元模型（取自两个提出者姓名的首字母），这是最早、也是最简单的神经网络算法的模型。</p>
<h4 id="16-1-1、生物神经元"><a href="#16-1-1、生物神经元" class="headerlink" title="16.1.1、生物神经元"></a>16.1.1、生物神经元</h4><p>神经元是大脑神经系统重要组成单位，主要由细胞体、树突、轴突、突触组成。神经元是一种<strong>多输入单输出</strong>的信息处理单元，输入的电信号有两种，分别是兴奋性信号和抑制性信号。</p>
<ul>
<li>树突，可以看作输入端，接受从从其他细胞传递过来的电信号；</li>
<li>轴突可以看作输出端，传递电信号给其他细胞；</li>
<li>突触，则可以看成 I&#x2F;O 接口，用于连接不同神经元，单个神经元可以和上千个神经元进行连接；</li>
</ul>
<p>细胞体内存在膜电位，外界传递过来电流时会使膜电位发生变化，当电位升高到一个阈值时，神经元就会被激活，产生一个脉冲信号，传递到下一个神经元。</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E7%94%9F%E7%89%A9%E7%A5%9E%E7%BB%8F%E5%85%83%E7%BB%84%E6%88%90.gif" alt="生物神经元组成" style="zoom:120%;">

<h4 id="16-1-2、M-P神经元"><a href="#16-1-2、M-P神经元" class="headerlink" title="16.1.2、M-P神经元"></a>16.1.2、M-P神经元</h4><p>M-P 模型就是基于生物神经构建的一种数学模型，只过不它将生物神经元信息传导过程进行了抽象化，并以网络拓扑相关知识来表示。</p>
<p>M-P 模型是神经网络的基本组成单位，在神经网络中也称为『节点（node）』或者『单元（unit）』。节点从其他节点接受输入，或从外部源接受输入（即 x1、x2、1），每个输入都带有一个权重值（weight，即 w），权重大小取决于输入值的相对重要性。函数 f 位于节点处，它是一个关于 ω、x 的线性函数，记做 f(x,ω) ，输入 b 表示函数的偏置项，最后经过 f(w,x) 的计算得输出 Y。模型如下所示：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E7%A5%9E%E7%BB%8F%E5%85%83%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B%E5%9B%BE.gif" alt="神经元模型示例图" style="zoom:150%;">

<p>上述模型对于神经网络说来说具有重要的意义，它是神经网络研究的开端，所示模型由 3 部分组成，从左往右依次为：神经元的输入、输入信号处理单元，以及神经元的输出。</p>
<p>M-P 模型采用数学模型模拟了生物神经元所包含的细胞体、树突、轴突和突出等生理特征。通过 M-P 模型提出了神经元的形式化数学描述和网络结构方法，从而证明了单个神经元能执行逻辑功能，但由于模型中的权重和偏置是人为设置的，因此该模型<strong>并不具备学习</strong>的能力。</p>
<h4 id="16-1-3、M-P模型解析"><a href="#16-1-3、M-P模型解析" class="headerlink" title="16.1.3、M-P模型解析"></a>16.1.3、M-P模型解析</h4><p>神经元是一种<strong>多端输入单端输出</strong>的信息处理单元，因此 M-P 神经元模型也遵循这个原理。神经元的输入端通常会被给予不同的权重，来权衡不同输入信号的重要程度，如上图所示是一个有 3 个输入，一个输出的神经元模型，该神经元模型接收 3 个输出信号，然后给予输入信号不同的权重，神经元的输入信号经过处理后得到神经元输出。注意，这里所说的信号可以理解为数据集中的数据样本。</p>
<h4 id="16-1-4、信息处理单元"><a href="#16-1-4、信息处理单元" class="headerlink" title="16.1.4、信息处理单元"></a>16.1.4、信息处理单元</h4><p>介于输入和输出之间的圆圈称为输入信息处理单元（即节点），之所以画成圆圈也是一种约定俗成的表示方式，而这个信息处理单元可以看成一个函数，当给这个模型“喂入”一个数据时，就会产生一个对应的输出。早期的 MP 神经元模型可以看成一种线性分类器，通过<strong>检验 f(x,ω) 的正负</strong>来识别两种不同类别的时输入。由此可知，该模型需要<code>正确设置权重参数</code>，才能使模型的输出对应所期望的类别。</p>
<h3 id="16-2、感知器模型"><a href="#16-2、感知器模型" class="headerlink" title="16.2、感知器模型"></a>16.2、感知器模型</h3><p>20 世纪 50年代（1957年），美国学者罗森勃拉特提出了感知器（或称感知机）模型，从某种意义上来说，<code>感知器模型是第一个具有学习能力的神经网络，该模型能根据每个类别的输入样本来学习权重。</code></p>
<p><strong>感知器模型</strong>，也可称为单层感知器，它是最简单的神经网络，它包含输入层和输出层，并且层与层之间直接相连。该模型从神经元模型的基础上发展而来，单层感知器能模拟逻辑与、逻辑或、逻辑非和逻辑与非等操作，单层感知器模型如下：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E6%84%9F%E7%9F%A5%E5%99%A8%E6%A8%A1%E5%9E%8B.gif" alt="感知器模型" style="zoom:120%;">


<p>虽然具备了学习的能力，但该模型只能解决简单的线性分类和线性回归问题，对于线性不可分问题（即异或问题，xor）仍无法解决（1969年，科学家明斯基和佩珀特证明）。如下图所示，无法找到一条直线可以把圆形和菱形分开：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E7%BA%BF%E6%80%A7%E4%B8%8D%E5%8F%AF%E5%88%86%E9%97%AE%E9%A2%98.gif" alt="线性不可分问题" style="zoom:120%;">

<p>感知器模型算法与神经元模型类似，是一个单层神经元结构，它首先对输入的数据进行<strong>加权求和</strong>，然后将得到的结果与阈值进行比较，假如与所期望的输出有较大误差，就对权值参数进行调整，反复多次，直到误差满足要求时为止。由上图可知单层感知器的输出为：<br>$$<br>\large<br>y(x_1,x_2) &#x3D; f(\omega_1 * x_1 + \omega_2 * x_2 - \theta)<br>$$<br>下面举个简单例子，看看单层感知器如何完成逻辑与运算（即 And，x1 ∧ x2）:</p>
<p>令 w1 &#x3D; w2 &#x3D;1，θ &#x3D; 1.5，则 y &#x3D;f(1<em>x1+1</em>x2-1.5)，显然，当 x1 和 x2 均为 1 时，y 的值为 1；而当 x1 和 x2 中有一个为 0 时，y 的值就为 0（通过 y 值的正负来取值，正值取值 1，负值取值 0，从而实现线性分类），当然逻辑或运算、与逻辑非运算也可通过此方法验证。</p>
<p>异或是一个数学运算符号，使用 ⊕ 来表示，计算机一般用 ^ 来表示。异或也叫半加运算，其运算法则相当于不带进位的二进制加法，用 1 表示真，用 0 表示假，运算法则为“同为 0，异为 1”。：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 ⊕ 0=0</span><br><span class="line">1 ⊕ 0=1</span><br><span class="line">0 ⊕ 1=1</span><br><span class="line">1 ⊕ 1=0</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 + 0 - θ ＜ 0 --&gt; θ &gt; 0</span><br><span class="line">ω1 + 0 - θ ≥ 0 --&gt; 0 ≥ θ - ω1</span><br><span class="line">0 + ω2 - θ ≥ 0 --&gt; 0 ≥ θ - ω2</span><br><span class="line">ω1 + ω2 - θ ＜ 0 --&gt; θ &gt; ω1 + ω2</span><br></pre></td></tr></table></figure>

<h4 id="16-2-1、激活函数"><a href="#16-2-1、激活函数" class="headerlink" title="16.2.1、激活函数"></a>16.2.1、激活函数</h4><p>上述感知器模型依然模拟了神经元结构，有输入（input）、权重（weight）、前馈运算（feed forward）、激活函数（activation function）、输出（output）等部分组成。注意，这里的前馈运算指的是图感知器模型中的『加权求和』，即在没有使用激活函数时输入值的加权求和结果，有时也记做『logit』。</p>
<p>通过上述模型很容易实现二分类。只需将对加权求和的结果值进行判断即可，比如 x&gt;0 为 1 类，若 x &lt;&#x3D;0 则为 0 类，这样就将输出结果值映射到了不同类别中，从而完成了二分类任务。激活函数公式如下：<br>$$<br>\large<br>f(x) &#x3D;<br>\begin{cases}<br>1,  &amp; \text{x &gt; 0} \<br>0,  &amp; \text{x&lt;&#x3D;0}<br>\end{cases}<br>$$<br>若想采用感知器模型解决线性回归问题就可以使用 sigmoid 函数，激活函数公式如下：<br>$$<br>\large<br>sigmoid(x) &#x3D; \frac{1}{1+e^{-x}}<br>$$</p>
<h4 id="16-2-2、多层感知器模型"><a href="#16-2-2、多层感知器模型" class="headerlink" title="16.2.2、多层感知器模型"></a>16.2.2、多层感知器模型</h4><p>由于单层感知器模型无法解决<strong>非线性可分</strong>问题，即 xor 问题（1969年，马文·明斯基证明得出），这也导致了神经网络热潮的第一次大衰退。直至 20 世纪 80 年代，多层感知器模型（Multi -Layer Perceptrons，缩写为 MLP）的提出（1981年，韦伯斯提出），神经网络算法再次回归大众视野。</p>
<p>与单层感知器模型相比，该模型在输入层与输出层之间增加了<code>隐藏层（Hidden）</code>，同时输出端，由原来一个增至两个以上（至少两个），从而增强了神经网络的表达能力。注意，对于只有一层隐藏层的神经网路，称为单隐层神经网络或者二层感知器，网络拓扑图如下所示：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E6%A8%A1%E5%9E%8B.gif" alt="多层感知器模型" style="zoom:130%;">

<p><strong>多层感知器模型</strong>是由多个<code>感知器</code>构造而成的，模型中每一个<code>隐藏层节点（或称单元）</code>都可以看做成一个感知器模型，当我们将这些感知器模型组合在一起时就可以得到“多层感知器模型”。输入层、隐藏层与输出层相互连接形成了神经网络，其中<code>隐藏网络层、输出层都是拥有激活函数的功能神经元（或称节点）</code>。</p>
<p>在神经网络中的隐藏层可以有多层，当隐藏层有多层，且形成一定“深度”时，神经网络便称为<strong>深度学习（deep learning）</strong>，这就是“深度学习”名字的由来。因此，深度学习就是<strong>包含了多个隐藏层的多层感知器模型</strong>。如下图所示，是具有两个隐藏层的神经网络：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%A4%E4%B8%AA%E9%9A%90%E8%97%8F%E5%B1%82%EF%BC%89.gif" alt="多层感知器模型（两个隐藏层）" style="zoom:120%;">

<p>但<strong>『深度学习』</strong>这一概念直到 2006 年才被提出，在这之前多层感知器模型被称为“人工神经网络”。从神经元模型到单层感知器模型再到多层感知器模型，这就是人工神经网络的发展过程。在神经网络中每层的节点与下一层节点相互连接，节点之间不存在同层连接，也不存跨层连接，这样的网络结构也被称为“<strong>多层前馈神经网络</strong>”（multi-layer feedforward neural），如果层与层之间的节点全部相互连接，则称为“<strong>全连接神经网络</strong>”，如下所示：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.gif" alt="全连接神经网络" style="zoom:120%;">

<p>多层感知器的诞生，解决了单层感知器模型无法解决的异或问题。下面简单分析一下解决过程。如图所示是包含了一个隐藏层的多层感知器模型：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E8%A7%A3%E5%86%B3%E5%BC%82%E6%88%96%E9%97%AE%E9%A2%98.gif" alt="多层感知器解决异或问题" style="zoom:150%;">

<p>在多层感知器模型中，隐藏层中的每一个节点都是想当于一个感知器模型。下面将输入值（x1 和 x2）带入隐藏层节点，可得以下函数式（这里的函数指的是激活函数）：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左隐藏层节点：f1(x1+x2-0.5)</span><br><span class="line">右隐藏层节点：f2(-x1-x2+1.5)</span><br></pre></td></tr></table></figure>

<p>由此可知输出层的函数式如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f3(f1+f2-1.5)</span><br></pre></td></tr></table></figure>

<p>根据异或法则“同为 0，异为 1”，分别将 (0,1)，(1,0)，(0,0)，(1,1) 带入上述三个函数分别进行计算，可得以下结果（正数为 1，负数为 0）：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(0,1)：f1(0+1-0.5)=1 f2(0-1+1.5)=1 --&gt; f3(1+1-1.5)=1 </span><br><span class="line">(1,0)：f1(1+0-0.5)=1 f2(-1-0+1.5)=1 --&gt; f3(1+1-1.5)=1 </span><br><span class="line">(0,0)：f1(0+0-0.5)=0 f2(0-0+1.5)=1 --&gt; f3(0+1-1.5)=0</span><br><span class="line">(1,1)：f1(1+1-0.5)=1 f2(-1-1+1.5)=0 --&gt; f3(1+0-1.5)=0</span><br></pre></td></tr></table></figure>

<p>可以看出输出层 f3 函数的结果完全符合异或运算法则，因此多层感知器可以解决“异或问题”。从函数图像上来看，多层感知器使用两条直线解决了线性不可分问题：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E5%88%86%E7%B1%BB%E5%8C%BA%E5%9F%9F.gif" alt="分类区域" style="zoom:150%;">

<p>上图所示，位于红色直线之间的属于正类，而位于区域之外则属于负类。当然图像中只是包含了四个点而已，若是复杂的数据则可以选择不同的激活函数，比如 sigmoid 函数等。</p>
<h3 id="16-3、神经网络工作流程"><a href="#16-3、神经网络工作流程" class="headerlink" title="16.3、神经网络工作流程"></a>16.3、神经网络工作流程</h3><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.gif" alt="人工神经网络模型" style="zoom:10%;">

<p>神经网络通过赋予输入信息<code>不同的权重值</code>来区别<code>不同信息的重要程度</code>。在模型训练过程中通过<code>调节线性函数的相应权值</code>，<code>增加有价值信息的输入权值</code>，<code>降低其他价值信息较低的输入权值</code>，这是<strong>【调优权值】</strong>的核心思想，通过上述方法能够提高网络模型预测的预测准确率。</p>
<h3 id="16-4、反向传播算法"><a href="#16-4、反向传播算法" class="headerlink" title="16.4、反向传播算法"></a>16.4、反向传播算法</h3><p>多层感知器的虽然解决了线性不可分问题，但随着隐藏层网络的加深，多层网络的训练和参数计算也越来越困难，因此多层感知器也显得“食之无味”。简单来说，就是当时的人们还不知道应该怎么训练多层神经网络，甚至不相信多层神经网络也是同样能被训练的。</p>
<p>直到 1986 年，深度学习教父 Hinton 等人对反向传播算法（Backpropagation algorithm，即误差逆向传播算法，简称 BP算法）进行了重新描述，证明了该算法可以解决网络层数过深导致的参数计算困难和误差传递等问题。</p>
<p>反向传播算法是一种用于训练神经网络的<code>有监督学习算法</code>，<code>基于梯度下降（gradient descent）策略</code>，以目标的<code>负梯度方向</code>对参数进行调整。但受限于当时（20世纪80年代）计算机算力不足等因素的影响，BP 算法只能以简单低效的方式来解决少数层神经网络训练问题，但即使如此，也已经弥足珍贵。</p>
<p>BP 算法的出现再次引发了 AI 研究的热潮，它是一款非常成功的神经网络算法，直到今天，该算法仍在深度学习领域发挥着重要的作用（用于训练多层神经网络）。</p>
<h4 id="16-4-1、正向传播"><a href="#16-4-1、正向传播" class="headerlink" title="16.4.1、正向传播"></a>16.4.1、正向传播</h4><p>人工神经网络是由一个个的神经元节点构成的，这些节点的作用就是负责接受和传导信息，如同大脑神经元一样，接受外接刺激，传递兴奋信号。</p>
<p>在一个人工神经网络模型中，<code>从输入层开始，传递到输出层，最后返回结果</code>，这种信号传播方式被称为“正向传播”（或称前向运算、前向传播）。在神经网络模型中，若输入一层层的传递下去的，直到输出层产生输出，正向传播就结束了。</p>
<p>反向传播的与前向传播类似，但由于传播方向相反，因此被称为反向传播算法（简称 BP 算法），该算法最早出现在 20 世纪 60 年代，但当时并没有引起重视，直到 1986 年经 Hinton 等人进行了重新描述，才再次进入大众的视野。该算法成功解决了少数层神经网络【权值参数】计算的问题。</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E5%89%8D%E5%90%91%E8%BF%90%E7%AE%97%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%A4%BA%E6%84%8F%E5%9B%BE.gif" alt="前向运算和反向传播示意图" style="zoom:120%;">

<h4 id="16-4-2、反向传播原理"><a href="#16-4-2、反向传播原理" class="headerlink" title="16.4.2、反向传播原理"></a>16.4.2、反向传播原理</h4><p>反向传播算法（BP）是一种<strong>有监督学习</strong>算法，即通过<strong>有标记的训练数据</strong>来学习，它是训练人工神经网络模型的常用方法之一。简单的来说，<code>BP 算法就是从错误中学习，直至将错误程度降到最低时结束，从而提高模型的可靠性</code>。</p>
<p>BP 算法的学习过程由正向传播过程和反向传播过程两部分组成。在正向传播过程中，输入信息通过输入层经隐含层，逐层处理并传向输出层，如果输出值与标记值存在误差，则将误差由输出层经隐藏层向输入层传播（即反向传播），并在这个过程中<code>利用梯度下降算法对神经元的各个权值参数进行调优</code>，当误差达到最小时，网络模型训练结束，也即反向传播结束。流程图如下所示：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83.gif" alt="神经网络模型训练" style="zoom:120%;">

<p>对上述过程进行总结：输入层接受一个输入数据 x，同时初始化一个权重参数 ω，通过隐藏层计算之后，由输出层输出结果，前向运算完成。之后，将输出层结果与标记值进行比较，获取偏差值，将此偏差值由输出层向输入层传播（反向传播阶段），这个阶段利用<code>梯度下降算法对权值参数进行反复调优</code>，<code>当偏差值最小时，获得一组最优的权值参数（ω）</code>。</p>
<h4 id="16-4-3、总结："><a href="#16-4-3、总结：" class="headerlink" title="16.4.3、总结："></a>16.4.3、总结：</h4><p>神经网络分类算法是一种有监督学习算法，使用神经网络分类算法，大致需要以下五步：</p>
<ul>
<li>初始化神经网络中所有神经元节点的权值；</li>
<li>输入层接收输入，通过正向传播产生输出；</li>
<li>根据输出的预测值，结合实际值计算偏差；</li>
<li>输出层接收偏差，通过反向传播机制（逆向反推）让所有神经元更新权值；</li>
<li>从第 2 步到第 4 步是一次完整的训练模型的过程，重复该过程，直到偏差值最小。</li>
</ul>
<p>神经网络算法通过反向传播机制让所有神经元实现了权值更新，当我们不断迭代上述训练过程，直到偏差值最小，最终就会得到一个最优的网络模型，实现了对数据的最佳拟合。</p>
<h3 id="16-5、神经网络分类算法的应用及其实现"><a href="#16-5、神经网络分类算法的应用及其实现" class="headerlink" title="16.5、神经网络分类算法的应用及其实现"></a>16.5、神经网络分类算法的应用及其实现</h3><h4 id="16-5-1、神经网络算法的特点"><a href="#16-5-1、神经网络算法的特点" class="headerlink" title="16.5.1、神经网络算法的特点"></a>16.5.1、神经网络算法的特点</h4><p>深度学习的本质就是神经网络算法（深度学习是神经网络算法的一个分支）。理论上来说，<code>在数据量和隐藏层足够多的情况下，神经网络算法能够拟合任何方程（函数）</code>。神经网络算法是一种具有<code>网络结构</code>的算法模型，这决定了它具有非常好的延展性，<code>通过调节神经网络中各个节点的权值参数使得分类效果明显提升</code>。总的来说，神经网络算法具有以下特点：</p>
<ol>
<li><p>黑盒算法</p>
<p>神经网络算法，也被称为“黑盒算法”，这是因为人们无法从外部得知神经网络模型究竟是如何完成训练的，比如使用一个预测准确率为 97% 的猫脸识别模型，有时会将小狗的脸部照片归纳到小猫中，而这种情况是无法解释的，因此神经网络算法又被人们形象地称之为“黑盒算法”。</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E9%BB%91%E7%9B%92%E7%AE%97%E6%B3%95.gif" alt="黑盒算法" style="zoom:150%;">

<p>由于神经网络算法的这一特性，导致一些场景并不适合使用神经网络算法，比如银行不会使用神经网络算法来评判用户的是否具备信用，因为一旦出现预测错误，银行根本无法溯源找到评判错误的原因，也就无法向客户做出合理的解释。</p>
</li>
<li><p>数据量</p>
<p>在互联网并不发达的七八十年代，数据量不足是阻碍神经网络发展的一大因素。与传统的机器学习算法相比，<code>要想训练一个优秀的神经网络模型，往往需要更多的数据（至少需要数千甚至数百万个标记样本）。</code></p>
<p>比如人脸识别，需要各种姿态样式的人脸，发怒的、喜悦的、悲伤的、戴眼镜的、模糊的等等，总之越多越好。海量数据集对于训练一个优秀的神经网络模型非常重要，神经网络获得数据越多，表现能力就越好，这样训练出来的模型才具有更好的泛化能力。</p>
</li>
<li><p>算力和开发成本高</p>
<p>在计算方面，比传统算法下相比，神经网络算法要耗费更多的计算机资源，对于复杂的深度学习模型来说，若想训练出一个优秀的模型，甚至需要几周的时间。但以 20 世纪七八十年代的计算机硬件水平，想要实现如此大规模的计算，几乎是不可能的。因此计算机的硬件性能也是影响神经网络发展的因素之一。</p>
<p>进入 21 世纪以后，计算机的硬件性能获得了飞速发展，这为神经网络的发展创造了有利的外部环境。</p>
<p>同时神经网络模型搭建过程较为复杂，<code>激活函数的选择，权值的调节</code>，都是一个比较费时的过程，因此其开发周期相对较长。总之，<strong>神经网络算法是一种成本较高的算法，这也决定了它能够解决比传统机器学习算法更为复杂的问题</strong>。下表对神经网络的特点做了简单的总结：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td><strong>网络结构延展性好，能够拟合复杂的数据分布</strong>，比如非线性函数，通过调节权值参数来获取泛化能力较强的模型。</td>
</tr>
<tr>
<td>缺点</td>
<td>可解释性差，调参依赖于经验，可能会陷入局部最优解，或者梯度消失、梯度爆炸等问题。</td>
</tr>
<tr>
<td>应用领域</td>
<td>神经网络算法拟合能力强，应用领域广，比如文本分类等，而深度学习作为神经网络的分支，也是当前最为热门研究方向，在<strong>图像处理、语言识别和自然语言处理</strong>等多个领域都有着非常突出的表现。</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="16-5-2、神经网络算法应用"><a href="#16-5-2、神经网络算法应用" class="headerlink" title="16.5.2、神经网络算法应用"></a>16.5.2、神经网络算法应用</h4><p>Python 机器学习 Sklearn 库提供了多层感知器算法（Multilayer Perceptron，即 MLP），也就是我们所说的神经网络算法，它被封装在 sklearn.neural_network 包中，该包提供了三个神经网络算法 API，分别是：</p>
<ul>
<li>neural_network.BernoulliRBM，伯努利受限玻尔兹曼机算法，无监督学习算法；</li>
<li>neural_network.MLPClassifier，神经网络分类算法，用于解决分类问题；</li>
<li>neural_network.MLPRgression，神经网络回归算法，用于解决回归问题。</li>
</ul>
<p>下面使用神经网络分类算法解决鸢尾花的分类问题。在这之前有必要先了解 neural_network.MLPClassifier 分类器常用参数，如下所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>hidden_layer_sizes</td>
<td>元组或列表参数，序列内元素的数量表示有多少个隐藏层，每个元素的数值表示该层有多少个神经元节点，比如(10,10)，表示两个隐藏层，每层10个神经元节点。</td>
</tr>
<tr>
<td>activation</td>
<td>隐藏层激活函数，参数值有 identity、logistic、tanh、relu，默认为 ‘relu’ 即线性整流函数（校正非线性）</td>
</tr>
<tr>
<td>solver</td>
<td>权重优化算法，lbfgs、sgd、adam，其中 lbfg 鲁棒性较好，但在大型模型或者大型数据集上花费的调优时间会较长，adam 大多数效果都不错，但对数据的缩放相当敏感，sgd 则不常用</td>
</tr>
<tr>
<td>alpha</td>
<td>L2 正则项参数，比如 alpha &#x3D; 0.0001（弱正则化）</td>
</tr>
<tr>
<td>learning_rate</td>
<td>学习率，参数值 constant、invscaling、adaptive</td>
</tr>
<tr>
<td>learning_rate_init</td>
<td>初始学习率，只有当 solver 为 sgd 或 adam 时才使用。</td>
</tr>
<tr>
<td>max_iter</td>
<td>最大迭代次数</td>
</tr>
<tr>
<td>shuffle</td>
<td>是否在每次迭代时对样本进行清洗，当 solver 参数值为 sgd 或 adam 时才使用该参数值</td>
</tr>
<tr>
<td>random_state</td>
<td>随机数种子</td>
</tr>
<tr>
<td>tol</td>
<td>优化算法中止的条件，当迭代先后的函数差值小于等于 tol 时就中止</td>
</tr>
</tbody></table>
<p>Iris 鸢尾花数据集内包含 3 个类别，分别是山鸢花（Iris-setosa）、变色鸢尾（Iris-versicolor）和维吉尼亚鸢尾（Iris-virginica）共150 条记录，每一个类别有 50 条数据，每条记录有 4 项特征（单位为厘米）：</p>
<ul>
<li>sepallength：萼片长度</li>
<li>sepalwidth：萼片宽度</li>
<li>petallength：花瓣长度</li>
<li>petalwidth：花瓣宽度</li>
</ul>
<p>选取两个类别（0 和 1，即山鸢尾花和变色鸢尾花）的样本标记值和两个特征属性（’sepal length (cm)’, ‘petal length (cm)’），之后使用神经网络分类算法对数据集中的 0 和 1 两类鸢尾花进行正确分类。代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    iris = datasets.load_iris()  <span class="comment"># 加载鸢尾花数据集</span></span><br><span class="line">    <span class="comment"># 用pandas处理数据集</span></span><br><span class="line">    data = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">    <span class="built_in">print</span>(iris.feature_names)</span><br><span class="line">    <span class="comment"># 数据集标记值 iris.target</span></span><br><span class="line">    data[<span class="string">&#x27;class&#x27;</span>] = iris.target</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此处只取两类 0/1 两个类别的鸢尾花，设置类别不等于 2</span></span><br><span class="line">    data = data[data[<span class="string">&#x27;class&#x27;</span>] != <span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 对数据集进行归一化和标准化处理</span></span><br><span class="line">    scaler = StandardScaler()</span><br><span class="line">    <span class="comment"># 选择两个特征值（属性）</span></span><br><span class="line">    X = data[[<span class="string">&#x27;sepal length (cm)&#x27;</span>, <span class="string">&#x27;petal length (cm)&#x27;</span>]]</span><br><span class="line">    <span class="comment"># 计算均值和标准差</span></span><br><span class="line">    scaler.fit(X)</span><br><span class="line">    <span class="comment"># 标准化数据集（数据转化）</span></span><br><span class="line">    X = scaler.transform(X)</span><br><span class="line">    <span class="comment"># &#x27;class&#x27;为列标签，读取100个样本的的列表</span></span><br><span class="line">    Y = data[[<span class="string">&#x27;class&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分数据集</span></span><br><span class="line">    X_train, X_test, Y_train, Y_test = train_test_split(X, Y)</span><br><span class="line">    <span class="comment"># 创建神经网络分类器</span></span><br><span class="line">    mpl = MLPClassifier(solver=<span class="string">&#x27;lbfgs&#x27;</span>, activation=<span class="string">&#x27;logistic&#x27;</span>)</span><br><span class="line">    <span class="comment"># 训练神经网络模型</span></span><br><span class="line">    mpl.fit(X_train, Y_train)</span><br><span class="line">    <span class="comment"># 打印模型预测评分</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Score:\n&#x27;</span>, mpl.score(X_test, Y_test))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分网格区域</span></span><br><span class="line">    h = <span class="number">0.02</span></span><br><span class="line">    x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">    y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))</span><br><span class="line">    Z = mpl.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">    Z = Z.reshape(xx.shape)</span><br><span class="line">    <span class="comment"># 画三维等高线图，并对轮廓线进行填充</span></span><br><span class="line">    plt.contourf(xx, yy, Z, cmap=<span class="string">&#x27;summer&#x27;</span>)</span><br><span class="line">    <span class="comment"># 绘制散点图</span></span><br><span class="line">    class1_x = X[Y[<span class="string">&#x27;class&#x27;</span>] == <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    class1_y = X[Y[<span class="string">&#x27;class&#x27;</span>] == <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    l1 = plt.scatter(class1_x, class1_y, color=<span class="string">&#x27;b&#x27;</span>, label=iris.target_names[<span class="number">0</span>])</span><br><span class="line">    class2_x = X[Y[<span class="string">&#x27;class&#x27;</span>] == <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    class2_y = X[Y[<span class="string">&#x27;class&#x27;</span>] == <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    l2 = plt.scatter(class2_x, class2_y, color=<span class="string">&#x27;r&#x27;</span>, label=iris.target_names[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    plt.legend(handles=[l1, l2], loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<h2 id="17、集成学习算法"><a href="#17、集成学习算法" class="headerlink" title="17、集成学习算法"></a>17、集成学习算法</h2><p>集成学习算法并非一种机器学习算法，它更像是一种<code>模型优化</code>方法，是一种<code>能在各种机器学习任务上提高准确率的强有力技术</code>，这种技术的关键体现在“集成”两个字上，所谓集成就是“捏在一起”，因此集成学习算法可以理解成是<code>一套组合了多种机器学习算法模型的框架</code>，它关注的是框架内各个模型之间的组织关系，而非某个模型的具体内部结构。</p>
<p>可以说集成学习算法是“集”百家之长，使预测模型获得较高准确率，当然这也导致了模型的训练过程会稍加复杂，效率降低了一些，但在硬件性能发达的今天，几乎可以忽略不计。</p>
<h3 id="17-1、集成学习发展史"><a href="#17-1、集成学习发展史" class="headerlink" title="17.1、集成学习发展史"></a>17.1、集成学习发展史</h3><p>集成学习算法的理论、应用体系的构建与完善经历一个漫长的过程，下面进行简单地介绍。</p>
<p>集成学习最早出现于 1979 年，Dasarathy 提出了集成系统（Ensemble system） 的思想，他使用线性分类器和最近邻居分类器组成的复合模型进行训练，得到了比单个分类器训练更好的预测效果。</p>
<p>1988 年 Kearns 提出了<strong>“弱学习器”</strong>概念，引发了<strong>“能否用一组弱学习器创造一个强学习器”</strong>的广泛讨论。（学习器，指的是某种机器学习算法模型），注意，所谓<strong>弱学习器</strong>，指的是一个个单独的算法模型，比如 KNN 算法模型、线性回归模型、朴素贝叶斯等，而<strong>强学习器</strong>指的是由多个不同类别的<strong>“弱学习器”</strong>集成的学习器，也称“异质集成”，这类学习器的预测准确率在 90% 以上。除此之外，还有一种<strong>“基学习器”</strong>（也称同质集成），它是由同一款机器学习算法组成的。</p>
<p>1990 年 Schapire 对这问题给出了答案，并且研发了著名的 Boosting 算法，该算法是集成学习常用方法之一；1992 年 Wolpert 首次提出<strong>“堆叠泛化”</strong>这一概念，即<strong>“堆叠”</strong>弱学习器训练的模型比任何单个弱学习器训练的模型具有更好的性能。</p>
<p>1996年，Breiman 开发了另一个集成学习方法 —— Bagging 算法（也称装袋算法），并对其原理和训练过程进行了详细的描述，并明确指出 Bagging 算法能够提高预测的准确性。其后几年，Breiman 在 Bagging 算法的基础上对<strong>“随机决策森林”</strong>进行另外重新描述，提出了集成学习中最广为人知的算法 —— <strong>随机森林算法（RandomForest）</strong>，该算法通过集成学习的思想将多棵<strong>“决策树”</strong>集成为一片<strong>“森林”</strong>，使其兼顾了解决回归问题和分类问题的能力。</p>
<p>截止到目前，已经有越来越多的集成学习算法被提出，比如 2010 年 Kalal 等人提出的 P-N 学习，以及近几年提出的以堆叠方式构建的深度网络结构、XGBoost 等算法，它们都能显著提升模型的预测效果。</p>
<h3 id="17-2、集成学习组成方式"><a href="#17-2、集成学习组成方式" class="headerlink" title="17.2、集成学习组成方式"></a>17.2、集成学习组成方式</h3><p>集成学习不是一种独立的机器学习算法，而是把互相没有关联的机器学习算法“集成”在一起，从而取得更好的效果。每个算法模型都有各自的局限性，集成学习方式的出现正好弥补了这一不足之处。</p>
<p>总的来说，集成学习算法主要使用两种结构来管理模型与模型之间的关系，一种是并联，另一种是串联（这和物理上串联电路、并联电路似乎有些相似之处）。下面对这两种方式进行简单介绍。</p>
<ol>
<li><p>并联组织关系</p>
<p>所谓并联，就是训练过程是并行的，几个学习器<code>相对独立地完成预测工作，彼此互不干扰</code>，当所有模型预测结束后，最终以某种方法<code>把所有预测结果合在一起</code>。并行式集成学习的典型代表是 Bagging 算法。并行结构示意图如下所示：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E5%B9%B6%E8%81%94%E7%BB%93%E6%9E%84.gif" alt="集成学习并联结构" style="zoom:120%;">
</li>
<li><p>串联组织关系</p>
<p>串联结构指的是训练过程是串行的，几个学习器<strong>串</strong>在一起，通力合作一起来完成预测任务。第一个学习器拿到数据集完成预测，然后把预测结果以及相关数据传递给第二个学习器，第二个学习器也是在完成预测后把结果和相关数据继续传递下去，直至传递到最后一个学习器。串行式集成学习的典型代表是 Boosting 算法。串行结构示意图如下所示：</p>
<img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E4%B8%B2%E8%81%94%E7%BB%93%E6%9E%84.gif" alt="集成学习串联结构" style="zoom:120%;"></li>
</ol>
<p>如果<code>各个学习器势均力敌，分不出主次优劣，在这种情况下建议选择并联结构</code>；如果学习器已经<code>有了明确的分工，知道谁负责主攻，谁负责辅助，则可以使用串联结构</code>。</p>
<h3 id="17-3、预测结果的方式"><a href="#17-3、预测结果的方式" class="headerlink" title="17.3、预测结果的方式"></a>17.3、预测结果的方式</h3><p>不管是串联结构，亦或是并联结构，最终都要输出一个预测结果，而在一个组织结构会有多个学习器，因此就会产生多个预测结果，那么我们要怎么将这些结果整合成一个结果对外输出呢，也就是使用什么方式来整合每个学习器的输出结果呢。对于集成学习算法来说，把多个结果整合成一个结果的方法主要有两种，分别是平均法和投票法，下面分别对它们进行介绍。</p>
<h4 id="17-3-1、平均法"><a href="#17-3-1、平均法" class="headerlink" title="17.3.1、平均法"></a>17.3.1、平均法</h4><p>平均法，又分为简单平均法和加权平均法，<strong>简单平均法</strong>就是先求和然后再求均值，而<strong>加权平均</strong>则多了一步，即每个学习器通过训练被分别赋予合适的权值，然后求各个预测结果的加权和，最后再求均值。</p>
<h4 id="17-3-2、投票法"><a href="#17-3-2、投票法" class="headerlink" title="17.3.2、投票法"></a>17.3.2、投票法</h4><p>投票法，具体分为三种：简单多数投票法、绝对多数投票法和加权投票法。</p>
<ol>
<li><p>简单多数投票法就是哪个预测结果占大多数，就把这个结果就作为最终的预测结果；</p>
</li>
<li><p>绝对多数投票法就多了一个限制，这个“多数”必须达到半数，比如有共有 6 个学习器，得出同一预测结果的必须达到 3 个及以上，否则就拒绝进行预测。</p>
</li>
<li><p>加权投票法，有点类似加权平均，首先给不同的学习器分配权值，其次是查看哪个结果占大多数，注意，此处有一点儿不同，这里的“大多数”是权值相加后再比较得到的大多数，最后以得票最多的作为预测结果。</p>
<p>关于加权投票法举一个简单的例子，比如预测结果为 A 的有 3 个学习器，权值分别为 0.1、0.2 和 0.3，那么结果 A 的票数就为三者之和，即 0.6，而预测结果为 B 的只有 2 个学习器，但权值分别为 0.4 和 0.5，那么结果 B 的票数就为 0.9，也就是结果 B 的票数高于结果 A，最终预测结果就是结果 B。</p>
</li>
</ol>
<h3 id="17-4、集成学习实现方式"><a href="#17-4、集成学习实现方式" class="headerlink" title="17.4、集成学习实现方式"></a>17.4、集成学习实现方式</h3><p>根据个体学习器生成方式的不同，目前集成学习的实现方式主要分为两种：</p>
<ul>
<li>一种是 Bagging 算法为代表的并行式集成学习方法，其中最典型的应用当数“随机森林算法”；</li>
<li>另一种是以 Boosting 算法为代表的串行式集成学习方法，其中应用频率较高的有两个 AdaBoost 算法和 XGBoost 算法。</li>
<li>除上述两种主要的方法外，还有一种 Stacking 分层模型集成学习算法。</li>
</ul>
<h4 id="17-4-1、Bagging算法"><a href="#17-4-1、Bagging算法" class="headerlink" title="17.4.1、Bagging算法"></a>17.4.1、Bagging算法</h4><p>Bagging 算法又称为“装袋算法”最初由 Leo Breiman 于 1996 年提出，它是并行式学习的典型代表，该算法主要是从数据层面上进行设计。并联结构中的每个学习器所使用的数据集均采用<strong>放回重采样</strong>的方式生成，也就是说，<code>每个学习器生成训练集时，每个数据样本都有相同的被采样概率</code>。训练完成后，Bagging 采用投票的方式进行预测。</p>
<p>通过放回重采样的方式来构建样本量相等、且相互独立的数据集，从而在同一算法中训练出不同的模型。Bagging 算法的集成策略比较简单，对于分类问题，一般通过投票法，以多数模型预测结果为最终结果；而对于回归问题，一般采用算术平均法，对所有模型的预测结果做算术平均得到最终结果。</p>
<h4 id="17-4-2、Boosting算法"><a href="#17-4-2、Boosting算法" class="headerlink" title="17.4.2、Boosting算法"></a>17.4.2、Boosting算法</h4><p>与 Bagging 算法相比，Boosting 是一种串行式集成学习算法，该算法基于<strong>错误</strong>来提升模型的性能，根据前面分类器分类错误的样本，调整训练集中各个样本的权重来重新构建分类器。</p>
<p>Boosting 可以组合多个弱学习器来形成一个强学习器，从而在整体上提高模型预测的准确率。在模型训练过程中，Boosting 算法总是更加关注被错误分类的样本，首先对于第一个弱学习器预测发生错误的数据，在后续训练中提高其权值，而正确预测的数据则降低其权值，然后基于调整权值后的训练集来训练第二个学习器，如此重复进行，直到训练完成所有学习器，最终将所有弱学习器通过集成策略进行整合（比如加权法），生成一个强学习器。</p>
<p>Boosting 算法的训练过程是呈阶梯状的，后一个学习器会在前一个学习器的基础上进行学习，最终以某种方式进行综合，比如加权法，对所有模型的预测结果进行加权来产生最终的结果。</p>
<h3 id="17-5、随机森林算法"><a href="#17-5、随机森林算法" class="headerlink" title="17.5、随机森林算法"></a>17.5、随机森林算法</h3><p>随机森林（Random Forest，简称RF）是通过集成学习的思想将多棵树集成的一种算法，它的基本单位是决策树模型，而它的本质属于机器学习的一大分支——集成学习（Ensemble Learning）方法。集成学习的实现方法主要分为两大类，即 Bagging 和 boosting 算法，随机森林就是通过【Bagging 算法+决策树算法】实现的。</p>
<h4 id="17-5-1、随机森林"><a href="#17-5-1、随机森林" class="headerlink" title="17.5.1、随机森林"></a>17.5.1、随机森林</h4><p>随机森林，顾名思义，即使用<strong>随机</strong>的方式建立一个森林，这个森林由很多的<code>决策树</code>组成，并且每一棵决策树之间是<code>相互独立</code>的。</p>
<p>如果训练集有 M 个样本，对于每棵数而言，以<strong>随机</strong>且有放回的方式从训练集中抽取 N 个训练样本（N&lt;M），作为该棵决策树的训练集。除了采用<code>样本随机</code>之外，随机森林还采用了<code>特征随机</code>。假设每个样本有 K 个特征，从所有特征中随机选取 k 个特征（k&lt;&#x3D;K），选择最佳分割属性作为节点建立 CART 决策树，重复该步骤，建立 m 棵 CART 树，这些树就组成了森林，这也是随机森林名字的由来。随机采样和随机特征选取在一定程度上避免了过拟合现象的发生。</p>
<p>当有一个新的输入样本进入森林时，就让森林中的每一棵决策树分别对其进行判断，看看这个样本应该属于哪一类（对于分类算法而言），然后使用少数服从多数的【投票法】，看看哪一类被选择最多，就预测该样本为哪一类。在这个过程中，森林中每棵数都是独立地对若干个弱分类器的分类结果进行投票选择，从而组成一个强分类器。</p>
<p>随机森林既可以处理属性为离散值的样本（即分类问题），也可以处理属性为连续值的样本（即回归问题），另外随机森林还可以应用于无监督学习的聚类问题，以及异常点检测。</p>
<h4 id="17-5-2、算法应用"><a href="#17-5-2、算法应用" class="headerlink" title="17.5.2、算法应用"></a>17.5.2、算法应用</h4><p>在 Scikit-Learn 机器学习库中提供了 Bagging 和 Boosting 两种集成学习方法，且都在 <strong>ensemble</strong> 类库下，包括随机森林算法。除此之外，该类库下还包含了其他几类算法，较为知名有如下几种：</p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RandomForestClassifier类</td>
<td>使用随机森林（Random Forest）算法解决分类问题，随机森林可谓 Bagging 集成学习算法的典型代表，它选择以 CART 决策树算法作为弱学习器，是一种常用的机器学习算法。</td>
</tr>
<tr>
<td>RandomForestRegressor类</td>
<td>使用随机森林算法解决回归问题</td>
</tr>
<tr>
<td>ExtraTreesClassifier类</td>
<td>使用极端随机树（Extra Tree）算法解决分类问题，极端随机树算法可以看作随机森林算法的一种变种，主要原理非常类似，但在决策条件选择时采用了随机选择的策略。</td>
</tr>
<tr>
<td>ExtraTreesRegressor类</td>
<td>使用极端随机树算法解决回归问题。</td>
</tr>
<tr>
<td>AdaBoostRegressor类</td>
<td>使用AdaBoost算法解决分类问题，AdaBoost算法是最知名的Boosting算法之一。</td>
</tr>
<tr>
<td>AdaBoostRegressor类</td>
<td>使用AdaBoost算法解决回归问题。</td>
</tr>
<tr>
<td>GradientBoostingClassifier类</td>
<td>使用Gradient Boosting算法解决分类问题，Gradient Boosting算法常常搭配CART决策树算法使用，这就是有名的梯度提升树（Gradient Boosting Decision Tree,GBDT）算法。</td>
</tr>
<tr>
<td>GradientBoostingRegressor类</td>
<td>使用Gradient Boosting算法解决回归问题。</td>
</tr>
</tbody></table>
<p>Scikit-Learn 对于集成学习方法做了非常良好的封装，可以实现“开箱即用”，下面以随机森林算法为例进行演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="comment"># 从Scikit-Learn库导入集成学习模型的随机森林分类算法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 载入鸢尾花数据集</span></span><br><span class="line">    X, y = load_iris(return_X_y=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    <span class="comment"># 随机森林与决策树算法一样，其中有一个名为“criterion”的参数</span></span><br><span class="line">    <span class="comment"># 同样可以传入字符串“gini”或“entropy”，默认使用的是基尼指数</span></span><br><span class="line">    clf = RandomForestClassifier()</span><br><span class="line">    clf.fit(X, y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型预测准确率&quot;</span>, clf.score(X, y))</span><br><span class="line">    <span class="comment"># 使用模型进行分类预测</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;预测结果:&quot;</span>, clf.predict(X))</span><br></pre></td></tr></table></figure>

<h4 id="17-5-3、总结"><a href="#17-5-3、总结" class="headerlink" title="17.5.3、总结"></a>17.5.3、总结</h4><p>随机森林算法是集成学习方法的典型代表，该算法具有以下特点：</p>
<ul>
<li>模型准确率高：随机森林既可以处理分类问题，也可以处理回归问题，即使存在部分数据缺失的情况，随机森林也能保持很高的分类精度；</li>
<li>能够处理数量庞大的高维度的特征，且不需要进行降维（因为特征子集是随机选择的）；</li>
<li>能够评估各个特征在分类问题上的重要性：可以生成树状结构，判断各个特征的重要性；</li>
<li>对异常值、缺失值不敏感。</li>
</ul>
<p>当然随机森林算法也存在一些不足，比如：</p>
<ul>
<li>随机森林解决回归问题的效果不如分类问题；</li>
<li>树之间的相关性越大，错误率就越大；</li>
<li>当训练数据噪声较大时，容易产生过拟合现象。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://hqzqaq.github.io/2022/09/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/09/23/%E5%9F%BA%E4%BA%8E-cancal-%E8%BF%9B%E8%A1%8C-mysql-%E4%B8%8E-es-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            基于 cancal 进行 mysql 与 es 的数据同步
          
        </div>
      </a>
    
    
      <a href="/2022/09/23/java8-GDAL%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">java8 GDAL环境构建</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> hqz
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="hqz的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/java/">java</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/machineLearning/">机器学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/webGIS/">webGIS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/bigData/">大数据</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/gis/">GIS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/essays/">随笔</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/other/">other</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>