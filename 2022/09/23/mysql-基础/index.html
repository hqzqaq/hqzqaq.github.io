<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>mysql 基础 |  hqz的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-mysql-基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  mysql 基础
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/23/mysql-%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-09-23T05:49:39.000Z" itemprop="datePublished">2022-09-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">32 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="MySql学习"><a href="#MySql学习" class="headerlink" title="MySql学习"></a>MySql学习</h1><blockquote>
<ol>
<li>数据库指令</li>
<li>mysql 数据库函数</li>
<li>事务</li>
<li>索引</li>
<li>权限管理和备份</li>
<li>mysql 备份</li>
<li>数据库设计</li>
<li>sql 语句性能优化</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="1、数据库指令"><a href="#1、数据库指令" class="headerlink" title="1、数据库指令"></a>1、数据库指令</h2><h3 id="1-1、TRUNCATE-命令"><a href="#1-1、TRUNCATE-命令" class="headerlink" title="1.1、TRUNCATE 命令"></a>1.1、TRUNCATE 命令</h3><ol>
<li>作用：完全清空一个数据库表，表的结构和索引约束不会变</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 清空student表</span><br><span class="line">TRUNCATE &#x27;student&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><font color="orange">delete </font>和 <font color="orange">TRUNCATE</font> 的区别<ul>
<li>相同点：都能删除数据，都不会删除表结构</li>
<li>不同点：<ul>
<li><font color="orange">TRUNCATE</font> 重新设置自增列，计数器会归零</li>
<li><font color="orange">TRUNCATE </font>不会影响事务</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-2、select"><a href="#1-2、select" class="headerlink" title="1.2、select"></a>1.2、select</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">all</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>]</span><br><span class="line">&#123;<span class="operator">*</span> <span class="operator">|</span> table.<span class="operator">*</span> <span class="operator">|</span> [table.field1[<span class="keyword">as</span> alias1][,table.field2[<span class="keyword">as</span> alias2]][,...]]&#125;</span><br><span class="line"><span class="keyword">FROM</span> table_name [<span class="keyword">as</span> table_alias]</span><br><span class="line">[<span class="keyword">left</span> <span class="operator">|</span> <span class="keyword">right</span> <span class="operator">|</span> <span class="keyword">inner</span> <span class="keyword">join</span> table_name2] <span class="comment">-- 联合查询</span></span><br><span class="line">[<span class="keyword">WHERE</span> ...] <span class="comment">-- 指定结果需满足的条件</span></span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span>] <span class="comment">-- 指定结果按照哪几个字段来分组</span></span><br><span class="line">[<span class="keyword">HAVING</span>] <span class="comment">-- 过滤分组的记录必须满足的次要条件</span></span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...] <span class="comment">-- 指定查询记录按一个或多个条件排序</span></span><br><span class="line">[LIMIT ] <span class="comment">-- 指定查询的记录从哪条至哪条</span></span><br></pre></td></tr></table></figure>



<h4 id="1-2-1、查询别名"><a href="#1-2-1、查询别名" class="headerlink" title="1.2.1、查询别名"></a>1.2.1、查询别名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;StudentNo&#x27;</span> <span class="keyword">as</span> 学号,<span class="string">&#x27;StudentName&#x27;</span> <span class="keyword">as</span> 学生姓名 <span class="keyword">from</span> student <span class="keyword">as</span> s</span><br><span class="line"><span class="comment">-- 函数 CONCAT(a,b) 连接两个字符串</span></span><br><span class="line"><span class="keyword">select</span> CONCAT(<span class="string">&#x27;姓名&#x27;</span>,StudentName) <span class="keyword">as</span> 新名字 <span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure>



<h4 id="1-2-2、去重-distinct"><a href="#1-2-2、去重-distinct" class="headerlink" title="1.2.2、去重 distinct"></a>1.2.2、去重 <font color="orange">distinct</font></h4><p>作用：去除 SELECT 查询出来的结果中重复的数据，重复的数据只显示一条</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DISTANCT <span class="string">&#x27;StudentNo&#x27;</span> <span class="keyword">FROM</span> <span class="keyword">result</span> <span class="comment">-- 去除重复数据</span></span><br></pre></td></tr></table></figure>



<h4 id="1-2-3、数据库的列"><a href="#1-2-3、数据库的列" class="headerlink" title="1.2.3、数据库的列"></a>1.2.3、数据库的列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION() <span class="comment">-- 查询mysql版本（函数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">*</span><span class="number">3</span><span class="number">-1</span> <span class="keyword">AS</span> 计算结果 <span class="comment">-- 计算结果（表达式）</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@auto</span>_increment_increment <span class="comment">-- 查询自增的步长（变量）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学员考试成绩 +1 分查看</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;StudentNo&#x27;</span>,<span class="string">&#x27;StudentResult&#x27;</span><span class="operator">+</span><span class="number">1</span> <span class="keyword">as</span> <span class="string">&#x27;提分后&#x27;</span> <span class="keyword">FROM</span> <span class="keyword">result</span></span><br></pre></td></tr></table></figure>

<p><font color="red">数据库中的表达式：文本值，列，Null，函数，计算表达式，系统变量….</font></p>
<p>select <font color="orange">表达式</font> from 表</p>
<h4 id="1-2-4、where-条件子句"><a href="#1-2-4、where-条件子句" class="headerlink" title="1.2.4、where 条件子句"></a>1.2.4、where 条件子句</h4><p>作用：检索数据中 <font color="orange">符合条件</font> 的值</p>
<p>搜索的条件由一个或者多个表达式组成！结果为 布尔值</p>
<ul>
<li><p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>语法</th>
<th>结果描述</th>
</tr>
</thead>
<tbody><tr>
<td>and  &amp;&amp;</td>
<td>a and b   a &amp;&amp; b</td>
<td>逻辑与</td>
</tr>
<tr>
<td>or  ||</td>
<td>a or b   a || b</td>
<td>逻辑或</td>
</tr>
<tr>
<td>not  !</td>
<td>not a   ! a</td>
<td>逻辑非</td>
</tr>
</tbody></table>
<p><font color="red">尽量使用英文字母</font></p>
</li>
<li><p>模糊查询：比较运算符</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>is null</td>
<td>a is null</td>
<td>如果操作符为null，结果为真</td>
</tr>
<tr>
<td>is not null</td>
<td>a is not null</td>
<td>如果操作符不为null，结果为真</td>
</tr>
<tr>
<td>between</td>
<td>a between b and c</td>
<td>若 a 在 b 和 c 之间，则结果为真</td>
</tr>
<tr>
<td><code>like</code></td>
<td>a like b</td>
<td>如果a 匹配到 b， 则结果为真</td>
</tr>
<tr>
<td>in</td>
<td>a in (a1,a2,a3….)</td>
<td>假设a在a1，或者a2… 其中的某一个值中，结果为真</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- like 结合 %（代表0到任意个字符） _（一个字符）</span></span><br><span class="line"><span class="keyword">SELECT</span> figure_name <span class="keyword">as</span> 历史人物名 <span class="keyword">FROM</span> history_figure </span><br><span class="line"><span class="keyword">WHERE</span> figure_name <span class="keyword">LIKE</span> <span class="string">&#x27;周%&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询年龄等于 50，60，70的历史人物 in() 里面是一个具体的值</span></span><br><span class="line"><span class="keyword">SELECT</span> figure_name,age <span class="keyword">FROM</span> history_figure</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">in</span> (<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>)</span><br></pre></td></tr></table></figure>



<h4 id="1-2-5、联表查询"><a href="#1-2-5、联表查询" class="headerlink" title="1.2.5、联表查询"></a>1.2.5、联表查询</h4><ul>
<li><p>left join、right join、inner join</p>
<p><img src="https://gis-visualization.oss-cn-beijing.aliyuncs.com/typoraImg/t3ajOBY4UdqerPy.jpg" alt="img"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- join（连接的表） on（判断的条件） 连接查询</span></span><br><span class="line"><span class="comment">-- where 等值查询</span></span><br><span class="line"><span class="comment">-- 交集 找到两张表的交叉点</span></span><br><span class="line"><span class="keyword">SELECT</span> figure_name,age,sort <span class="keyword">FROM</span> history_figure <span class="keyword">as</span> hf</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> figure_location <span class="keyword">as</span> fl <span class="keyword">ON</span> hf.id <span class="operator">=</span> fl.figure_id</span><br><span class="line"><span class="comment">-- left join 展示左表所有的数据，右表符合 on 条件的数据，右表不符合的则为空显示</span></span><br><span class="line"><span class="comment">-- inner join 显示两表的信息</span></span><br><span class="line"><span class="comment">-- 左右join 以哪张表为基准</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Inner join</td>
<td>如果表中至少有一个匹配，则返回行</td>
</tr>
<tr>
<td>left join</td>
<td>返回左表中所有的值、即使右表中没有匹配</td>
</tr>
<tr>
<td>right join</td>
<td>返回右表中所有的值、即使左表中没有匹配</td>
</tr>
</tbody></table>
</li>
<li><p>自连接</p>
<p><font color="orange">自己的表和自己的表连接，核心：一张表拆为两张一摸一样的表</font></p>
<p>父类</p>
<table>
<thead>
<tr>
<th>pid（一级id）</th>
<th>categoryid</th>
<th>categoryName</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>信息技术</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>软件开发</td>
</tr>
<tr>
<td>1</td>
<td>5</td>
<td>美术设计</td>
</tr>
</tbody></table>
<p>子类</p>
<table>
<thead>
<tr>
<th>pid</th>
<th>categoryid</th>
<th>categoryName</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>4</td>
<td>数据库</td>
</tr>
<tr>
<td>2</td>
<td>8</td>
<td>办公信息</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>web开发</td>
</tr>
<tr>
<td>5</td>
<td>7</td>
<td>ps技术</td>
</tr>
</tbody></table>
<p> 操作：查询父类对应的子类关系</p>
<table>
<thead>
<tr>
<th>父类</th>
<th>子类</th>
</tr>
</thead>
<tbody><tr>
<td>信息技术</td>
<td>办公信息</td>
</tr>
<tr>
<td>软件开发</td>
<td>数据库</td>
</tr>
<tr>
<td>软件开发</td>
<td>web开发</td>
</tr>
<tr>
<td>美术设计</td>
<td>ps技术</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sql 自连接解决分级问题，递归</span></span><br><span class="line"><span class="keyword">SELECT</span> a.`name` <span class="keyword">as</span> 父菜单,b.`name` <span class="keyword">as</span> 子菜单 <span class="keyword">FROM</span> acl_permission <span class="keyword">as</span> a,acl_permission <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.id <span class="operator">=</span> b.pid <span class="keyword">AND</span> a.`is_deleted` <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>先分析要查询哪些字段，再连接表，注意别名，inner join</p>
</li>
</ul>
<h4 id="1-2-6、分页-limit-和排序-order-by"><a href="#1-2-6、分页-limit-和排序-order-by" class="headerlink" title="1.2.6、分页 limit 和排序 order by"></a>1.2.6、分页 limit 和排序 order by</h4><ul>
<li><p>排序 升序 asc 降序 desc</p>
</li>
<li><p>limit 当前页,页面的大小 limit (current_page - 1)*size,size</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span></span><br><span class="line">limit <span class="number">0</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-2-7、子查询"><a href="#1-2-7、子查询" class="headerlink" title="1.2.7、子查询"></a>1.2.7、子查询</h4><p>本质：<font color="orange">where语句中嵌套一个子查询语句</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 子查询（由里及外）</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;StudentNo&#x27;</span>,<span class="string">&#x27;SubjectNo&#x27;</span>,<span class="string">&#x27;StudentResult&#x27;</span> <span class="keyword">From</span> <span class="string">&#x27;result&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> SubjectNo <span class="operator">=</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> SubjectNo <span class="keyword">FROM</span> <span class="string">&#x27;subject&#x27;</span></span><br><span class="line">    <span class="keyword">WHERE</span> SUbjectName <span class="operator">=</span> <span class="string">&#x27;数据库结构-1&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 嵌套查询</span></span><br><span class="line"><span class="keyword">SELECT</span> StudentNo,StudentName <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> StudentNo <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> StudentNo <span class="keyword">FROM</span> <span class="keyword">result</span> <span class="keyword">WHERE</span> StudentResult <span class="operator">&gt;</span> <span class="number">80</span> <span class="keyword">AND</span> SubjectNo <span class="operator">=</span> (</span><br><span class="line">    	<span class="keyword">SELECT</span> SubjectNo <span class="keyword">FROM</span> subject <span class="keyword">WHERE</span> SubjectName <span class="operator">=</span> <span class="string">&#x27;高等数据-2&#x27;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>





<h2 id="2、mysql-数据库函数"><a href="#2、mysql-数据库函数" class="headerlink" title="2、mysql 数据库函数"></a>2、mysql 数据库函数</h2><h3 id="2-1、常用函数"><a href="#2-1、常用函数" class="headerlink" title="2.1、常用函数"></a>2.1、常用函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 常用函数 --</span></span><br><span class="line"><span class="comment">--数学运算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span>(<span class="number">-8</span>) <span class="comment">--绝对值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEILING</span>(<span class="number">9.4</span>) <span class="comment">--向上取整</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">9.4</span>) <span class="comment">--向下取整</span></span><br><span class="line"><span class="keyword">SELECT</span> RAND（） <span class="comment">-- 返回 0~1之间的随机数</span></span><br><span class="line"><span class="keyword">SELECT</span> SIGN（） <span class="comment">-- 判断一个数的符号 0-0 复数返回-1，正数返回1</span></span><br><span class="line">MD5() <span class="comment">-- MD5加密</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字符串函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;即使最小的帆也能远航&#x27;</span>) <span class="comment">-- 字符串长度</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;谁&#x27;</span>)  <span class="comment">-- 拼接字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSERT</span>(<span class="string">&#x27;我爱编程HelloWorld&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;超级热爱&#x27;</span>) <span class="comment">-- 查询，从某个位置开始替换某个长度</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>(<span class="string">&#x27;UUUU&#x27;</span>) <span class="comment">-- 转小写</span></span><br><span class="line"><span class="keyword">SELECT</span> UPER(<span class="string">&#x27;uuuu&#x27;</span>) <span class="comment">-- 转大写</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hqz&#x27;</span>,<span class="string">&#x27;h&#x27;</span>) <span class="comment">-- 返回第一次出现的子串索引</span></span><br><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">&#x27;hqz&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,h) <span class="comment">-- 替换出现的指定字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hqz&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>) <span class="comment">-- 返回指定的子字符串（源字符串）</span></span><br><span class="line"><span class="keyword">SELECT</span> REVERSE(<span class="string">&#x27;hqz&#x27;</span>) <span class="comment">-- 反转</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 时间日期函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>() <span class="comment">-- 获取当前日期 2021-03-29</span></span><br><span class="line"><span class="keyword">SELECT</span> CURDATE()</span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="comment">-- 获取当前时间 2021-03-29 22:09:00</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW()) <span class="comment">-- 获取当前年</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 系统</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SYSTEM_USER</span>() <span class="comment">-- 获取当前登录的用户</span></span><br><span class="line"><span class="keyword">SELECT</span> USR()</span><br><span class="line"><span class="keyword">SELECT</span> VERSION() <span class="comment">-- 获取当前sql 的版本</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2、聚合函数"><a href="#2-2、聚合函数" class="headerlink" title="2.2、聚合函数"></a>2.2、聚合函数</h3><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><font color="orange">COUNT()</font></td>
<td>计数</td>
</tr>
<tr>
<td>SUM()</td>
<td>求和</td>
</tr>
<tr>
<td>AVG()</td>
<td>平均值</td>
</tr>
<tr>
<td>MAX()</td>
<td>最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>最小值</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(字段) <span class="comment">-- 会忽略所有null值</span></span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="comment">-- 不会忽略null值 本质：计算行数</span></span><br><span class="line"><span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="comment">-- 不会忽略null值</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3、分组和排序-HAVING"><a href="#2-3、分组和排序-HAVING" class="headerlink" title="2.3、分组和排序 HAVING"></a>2.3、分组和排序 HAVING</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT any_value(SubjectName),AVG(StudentResult) as 平均分,MAX(StudentResult) as 最高分,MIN(StudentResult) as 最低分</span><br><span class="line">FROM RESULT r</span><br><span class="line">INNER JOIN `subject` sub</span><br><span class="line">ON r.`SubjectNo` = sub.`SubhectNO`</span><br><span class="line">GROUP BY r.SubjectNo -- 通过什么字段分组</span><br><span class="line">HAVING 平均分 &gt; 80</span><br></pre></td></tr></table></figure>

<h2 id="3、事务"><a href="#3、事务" class="headerlink" title="3、事务"></a>3、事务</h2><p><font color="orange">要么都成功，要么都失败</font></p>
<p>把一组sql放在一个批次中去执行</p>
<h3 id="3-1、事务原则"><a href="#3-1、事务原则" class="headerlink" title="3.1、事务原则"></a>3.1、事务原则</h3><ul>
<li><p>ACID原则，原子性、一致性、隔离性、持久性 </p>
</li>
<li><p><strong>原子性</strong>：<font color="orange">要么一起成功，要么一起失败</font></p>
</li>
<li><p><strong>一致性</strong>：事务前后的数据完整性要保持一致</p>
</li>
<li><p><strong>隔离性</strong>：针对多个用户同时操作，排除其它事务对本次事务的影响</p>
</li>
<li><p><strong>持久性</strong>：事务结束后的数据不随外界原因丢失，<font color="orange">事务一旦提交则不可逆</font>被持久化到数据库中</p>
</li>
<li><p>隔离导致的一些问题</p>
<ul>
<li><strong>脏读</strong>：指一个事务读取了另外一个事务未提交的数据</li>
<li><strong>不可重复读</strong>：在一个事务内读取表中的某一行数据，多次读取结果不同</li>
<li><strong>虚读（幻读）</strong>：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致（一般是行影响，多了一行）</li>
</ul>
</li>
<li><p>&#96;&#96;&#96;mysql<br>– 事务<br>– MySQL 是默认开启事务自动提交的<br>SET autocommit &#x3D; 0 –关闭事务自动提交<br>SET autocommit &#x3D; 1 – 开启事务自动提交（默认）</p>
<p>– 手动处理事务<br>SET autocommit &#x3D; 0 – 关闭自动提交</p>
<p>– 事务开启<br>START TRANSACTION – 标记一个事务的开始，从这个之后的sql都在同一个事务内<br>– 执行sql<br>INSERT xx<br>INSERT xx</p>
<p>– 提交：持久化（成功）<br>COMMIT<br>– 回滚：回到事务开始之前（失败）<br>ROLLBACK</p>
<p>– 事务结束<br>SET autocommit &#x3D; 1 – 开启自动提交</p>
<p>– 了解<br>SAVEPOINT 保存点名 – 设置一个事务的保存点<br>ROLLBACK TO SAVEPOINT 保存点名 – 回滚到保存点<br>RELEASE SAVEPOINT 保存点名 – 撤销保存点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 4、索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">索引（index）是帮助Mysql高效获取数据的数据结构，索引是一种数据结构</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4.1、索引的分类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **主键索引（PRIMARY KEY）**</span><br><span class="line"></span><br><span class="line">  - 唯一的标识，主键不可重复，只能有一个列作为主键</span><br><span class="line"></span><br><span class="line">- **唯一索引（UNIQUE KEY）**</span><br><span class="line"></span><br><span class="line">  - 避免重复的列出现，唯一索引可以重复，多个列都可以标识为唯一索引</span><br><span class="line"></span><br><span class="line">- **常规索引（KEY/INDEX）**</span><br><span class="line"></span><br><span class="line">  - 默认的 index、key关键字来设置</span><br><span class="line"></span><br><span class="line">- **全文索引（FullText）**</span><br><span class="line"></span><br><span class="line">  - 在特定的数据库引擎下才有，&lt;font color=&#x27;orange&#x27;&gt;MylSAM&lt;/font&gt;</span><br><span class="line">  - 快速定位数据</span><br><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  -- 索引的使用</span><br><span class="line">  -- 1、在创建表的时候给字段增加索引</span><br><span class="line">  -- 2、创建完毕后，增加索引</span><br><span class="line">  </span><br><span class="line">  -- 显示所有的所有信息</span><br><span class="line">  SHOW INDEX FROM student</span><br><span class="line">  </span><br><span class="line">  -- 增加一个全文索引</span><br><span class="line">  ALTER TABLE school.student ADD FULLTEXT INDEX `studentName`(`studentName`);</span><br><span class="line">  </span><br><span class="line">  -- EXPLAIN 分析sql执行的状况</span><br><span class="line">  EXPLAIN SELECT * FROM student; -- 非全文索引</span><br><span class="line">  </span><br><span class="line">  EXPLAIN SELECT * FROM student WHERE MATCH(studentName) AGAINST(&#x27;刘&#x27;);</span><br><span class="line">  </span><br><span class="line">  -- id_表名_字段名</span><br><span class="line">  -- CREATE INDEX 索引名 on 表（字段）</span><br><span class="line">  CREATE INDEX id_app_user_name ON app_user(`name`);</span><br></pre></td></tr></table></figure>

<p><font color="orange">索引在小数据量的时候用处不大，但是在大数据的时候，区别十分明显</font></p>
</li>
</ul>
<h3 id="4-2、索引原则"><a href="#4-2、索引原则" class="headerlink" title="4.2、索引原则"></a>4.2、索引原则</h3><ul>
<li>索引不是越多越好</li>
<li>不要对经常变动的数据加索引</li>
<li>小数据量的表不需要加索引</li>
<li>索引一般加在常用来查询的字段上</li>
</ul>
<p><strong>索引的数据结构</strong></p>
<p><code>Hash </code>类型的索引</p>
<p><code>Btree</code>：InnoDB 的默认数据结构</p>
<h2 id="5、权限管理和备份"><a href="#5、权限管理和备份" class="headerlink" title="5、权限管理和备份"></a>5、权限管理和备份</h2><p><strong>用户管理</strong></p>
<p>mysql.user 表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户 CREATE USER 用户名 IDENTIFIED BY &#x27;密码&#x27;</span><br><span class="line">CREATE USER HQZ IDENTIFIED BY &#x27;123456&#x27;</span><br><span class="line"></span><br><span class="line">-- 修改密码（修改当前用户密码）</span><br><span class="line">SET PASSWORD = PASSWORD(&#x27;123456&#x27;)</span><br><span class="line"></span><br><span class="line">-- 修改密码（修改指定用户密码）</span><br><span class="line">SET PASSWORD FOR HQZ = PASSWORD(&#x27;111111&#x27;)</span><br><span class="line"></span><br><span class="line">-- 重命名 RENAME USER 原名 TO 新名</span><br><span class="line">RENAME USER hqz TO HQZ2</span><br><span class="line"></span><br><span class="line">-- 用户授权 ALL PRIVILEGES 全部的权限 ， 库 表</span><br><span class="line">-- ALL PRIVILEGES 除了不能给别人授权，其它都能干</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO hqz</span><br><span class="line"></span><br><span class="line">-- 查询权限</span><br><span class="line">SHOW GRANTS FOR hqz -- 查看指定用户的权限</span><br><span class="line">SHOW GRANTS FOR root@localhost -- GRANT PROXY ON &#x27;&#x27;@&#x27;&#x27; TO &#x27;root&#x27;@&#x27;localhost&#x27; WITH GRANT OPTION</span><br><span class="line"></span><br><span class="line">-- 撤销权限 REVOKE 哪些权限 ， 在哪个库撤销，给谁撤销</span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM hqz</span><br><span class="line"></span><br><span class="line">-- 删除用户</span><br><span class="line">drop user hqz</span><br></pre></td></tr></table></figure>



<h2 id="6、Mysql备份"><a href="#6、Mysql备份" class="headerlink" title="6、Mysql备份"></a>6、Mysql备份</h2><p><code>MySQL数据库备份的方式</code>：</p>
<ul>
<li><p>直接拷贝物理文件</p>
</li>
<li><p>在可视化数据库管理工具中手动导出</p>
</li>
<li><p>使用命令行导出—— mysqldump 命令行使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqldump -h 主机 -u 用户名 -p 密码 数据库 表名 &gt; 物理磁盘位置/文件名</span></span><br><span class="line">mysqldump -hlocalhost -uroot -psqlserver gp history_figure &gt; E:/desktop/a.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 导入 sql 文件</span><br><span class="line">-- 登录的情况下</span><br><span class="line">source E:/desktop/a.sql</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7、数据库设计"><a href="#7、数据库设计" class="headerlink" title="7、数据库设计"></a>7、数据库设计</h2><p><font color="red">当数据库比较复杂的时候需要设计</font></p>
<p><code>糟糕的数据库设计</code>：</p>
<ul>
<li>数据冗余，浪费空间</li>
<li>数据库插入和删除都会麻烦、异常【屏蔽使用物理外键】</li>
</ul>
<p><code>良好的数据库设计</code>：</p>
<ul>
<li>节省内存空间</li>
<li>保证数据库的完整性</li>
<li>方便开发系统</li>
</ul>
<p><code>数据库设计</code>：</p>
<ul>
<li>分析需求：分析业务和需要处理的数据库的需求</li>
<li>概要设计：设计关系图 E-R 图</li>
</ul>
<p><code>设计数据库步骤</code>：（个人博客）</p>
<ul>
<li>收集信息，分析需求<ul>
<li>用户表（用户登录注销，用户的个人信息，写博客，创建分类）</li>
<li>分类表（文章分类，谁创建的）</li>
<li>文章表（文章的信息）</li>
<li>评论表</li>
<li>友链表（友链信息）</li>
<li>自定义表（系统信息，某个关键字，或者一些主字段）key：value</li>
<li>说说表（发表心情 .. id ..content ..create_time）</li>
</ul>
</li>
<li>标识实体（把需求落地到每个字段）</li>
<li>标识实体之间的关系<ul>
<li>写博客：user –&gt; blog</li>
<li>创建分类：user –&gt; category</li>
<li>关注：user –&gt; user</li>
<li>友链：links</li>
<li>评论：user –user –blog</li>
</ul>
</li>
</ul>
<h3 id="7-1、三大范式"><a href="#7-1、三大范式" class="headerlink" title="7.1、三大范式"></a>7.1、三大范式</h3><p><code>为什么需要数据规范化？</code></p>
<ul>
<li>信息重复</li>
<li>更新异常</li>
<li>插入异常<ul>
<li>无法正常显示信息</li>
</ul>
</li>
<li>删除异常<ul>
<li>丢失有效的信息</li>
</ul>
</li>
</ul>
<blockquote>
<p>三大范式</p>
</blockquote>
<p><code>第一范式（1NF）</code></p>
<p>​	原子性、要求数据库表的每一列都是不可分割的原子数据项</p>
<p><code>第二范式（2NF）</code></p>
<p>​	前提：满足第一方式</p>
<p>​	每张表只描述一件事情、消除依赖的传递性</p>
<p><code>第三范式（3NF）</code></p>
<p>​	前提：满足第一方式和第二范式</p>
<p>​	第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关</p>
<p><strong>规范性 和 性能的问题</strong></p>
<p>关联查询的表不得超过三张表</p>
<ul>
<li>考虑商业化的需求和目标，（成本，用户体验）数据库的性能更加重要</li>
<li>在规范性能的问题的时候，需要适当的考虑一下规范性</li>
<li>故意给某些表增加一些冗余字段。（从多表查询中变为单表查询）</li>
<li>故意增加一些计算列（从大数据量降低为小数据量的查询：索引）</li>
</ul>
<h2 id="8、SQL-语句性能优化"><a href="#8、SQL-语句性能优化" class="headerlink" title="8、SQL 语句性能优化"></a>8、SQL 语句性能优化</h2><ol>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 <code>where </code>及 <code>order by</code> 涉及的列上<code>建立索引</code>。</p>
</li>
<li><p>应尽量避免在 <code>where </code>子句中对字段进行 <code>null </code>值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，<strong>如0，-1作为默 认值。</strong></p>
</li>
<li><p>应尽量避免在 <code>where </code>子句中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符， MySQL只有对以下操作符才使用索引：<font color="orange">&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN，以及某些时候的LIKE。</font></p>
</li>
<li><p>应尽量避免在 <code>where </code>子句中使用 <code>or</code> 来连接条件， 否则将导致引擎放弃使用索引而进行全表扫描， 可以 使用 <code>UNION </code>合并查询：<code>select id from t where num=10 union all select id from t where num=20</code></p>
</li>
<li><p><code>in</code> 和 <code>not in</code> 也要慎用，否则会导致全表扫描，对于连续的数值，能用 <code>between </code>就不要用 <code>in</code> 了：<code>Select id from t where num between 1 and 3</code></p>
</li>
<li><p>下面的查询也将导致全表扫描：<code>select id from t where name like &#39;%abc%’ </code>或者 <code>select id from t where name like ‘%abc’</code> 若要提高效率，可以考虑全文检索。而 <code>select id from t where name like ‘abc%’</code> 才用到索引</p>
</li>
<li><p>如果在 <code>where </code>子句中使用<code>参数</code>，也会导致全表扫描。</p>
</li>
<li><p>应尽量避免在 <code>where </code>子句中对字段进行<code>表达式操作</code>，应尽量避免在<code>where</code>子句中对<code>字段</code>进行<font color="orange">函数操作</font></p>
</li>
<li><p>很多时候用 <code>exists </code> 代替 <code>in</code> 是一个好的选择：<code>select num from a where num in(select num from b)</code> 用下面的语句替换：<font color="orange">select num from a where exists(select 1 from b where num&#x3D;a.num)</font></p>
</li>
<li><p><code>索引</code> 固然可以提高相应的 <code>select </code>的效率，但同时也降低了 <code>insert </code>及 <code>update </code>的效率，因为 <code>insert </code>或 <code>update </code>时有可能会<font color="red">重建索引</font>，所以怎样建索引需要慎重考虑，视具体情况而定。<font color="orange">一个表的索引数最好不要超过6个</font>，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
</li>
<li><p>应尽可能的避免更新 <code>clustered </code> 索引数据列， 因为 <font color="orange">clustered 索引数据列的顺序就是表记录的物理存储顺序</font>，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 <code>clustered </code>索引数据列，那么需要考虑是否应将该索引建为 <code>clustered </code>索引。</p>
</li>
<li><p>尽量使用<code>数字型字段</code>，若<font color="orange">只含数值信息的字段尽量不要设计为字符型</font>，这会降低查询和连接的性能，并会增加存储开销。</p>
</li>
<li><p>尽可能的使用 <code>varchar/nvarchar</code> 代替 <code>char/nchar</code> ， 因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
</li>
<li><p>最好不要使用返回所有字段，<code>select * from t</code> ，用具体的字段列表代替  “*”，<font color="yellow">不要返回用不到的任何字段</font>。</p>
</li>
<li><p><font color="cornflowerblue">尽量避免向客户端返回大数据量</font>，若数据量过大，应该考虑相应需求是否合理。</p>
</li>
<li><p>使用表的别名( <code>Alias </code>)：当在SQL语句中连接多个表时,请<font color="yellow">使用表的别名并把别名前缀于每个 Column 上</font>.这样一来,就可以减少解析的时间并减少那些由 <code>Column </code>歧义引起的语法错误。</p>
</li>
<li><p>使用 <font color="orange">“ 临时表 ”</font> 暂存中间结果，简化SQL语句的重要方法就是采用<code>临时表</code>暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在<code>tempdb</code> 中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中 <code>“共享锁”</code> 阻塞 <code>“更新锁”</code>，减少了阻塞，提高了并发性能。</p>
</li>
<li><p>一些 SQL 查询语句应加上 <code>nolock</code>，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上 <code>nolock</code>，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。使用 <code>nolock</code> 有3条原则。查询的结果用于 <font color="orange">“插、删、改” </font>的不能加 <code>nolock </code>，查询的表属于频繁发生页分裂的，慎用 <code>nolock </code>！使用临时表一样可以保存 “数据前影”，起到类似 <code>Oracle</code> 的 <code>undo</code> 表空间的功能，能采用临时表提高并发性能的，不要用 <code>nolock</code> 。</p>
</li>
<li><p>常见的简化规则如下：不要有超过 <font color="orange">5</font> 个以上的<code>表连接（JOIN）</code>，考虑使用<code>临时表</code>或<code>表变量</code>存放中间结果。<font color="yellow">少用子查询</font>，视图嵌套不要过深,一般视图嵌套不要超过2个为宜。</p>
</li>
<li><p>将<font color="cornflowerblue">需要查询的结果预先计算好放在表中</font>，查询的时候再Select。这在SQL7.0以前是最重要的手段。例如医院的住院费计算。</p>
</li>
<li><p>用 <code>OR </code>的字句可以分解成多个查询，并且通过 <code>UNION </code>连接多个查询。他们的速度只同是否使用索引有关,如果查询需要用到联合索引，用 <font color="orange">UNION all</font> 执行的效率更高.多个 <code>OR</code> 的字句没有用到索引，改写成 <code>UNION </code>的形式再试图与索引匹配。一个关键的问题是否用到索引。</p>
</li>
<li><p>在 <code>IN </code>后面值的列表中，<font color="yellow">将出现最频繁的值放在最前面，出现得最少的放在最后面</font>，减少判断的次数。</p>
</li>
<li><p><font color="cornflowerblue">尽量将数据的处理工作放在服务器上</font>，减少网络的开销，如使用存储过程。存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL,可以使用临时存储过程，该过程（临时表）被放在Tempdb中。</p>
</li>
<li><p>当服务器的内存够多时，<font color="orange">配制线程数量 &#x3D; 最大连接数+5</font>，这样能发挥最大的效率；否则使用 <code>配制线程数量&lt;最大连接数</code>，启用 <code>SQL SERVER</code> 的线程池来解决,如果还是数量 &#x3D; 最大连接数+5，严重的损害服务器的性能。</p>
</li>
<li><p>查询的关联同写的顺序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.personMemberID, <span class="operator">*</span> <span class="keyword">from</span> chineseresume a,personmember b <span class="keyword">where</span> personMemberID <span class="operator">=</span> b.referenceid <span class="keyword">and</span> a.personMemberID <span class="operator">=</span> ‘JCNPRH39681’ （A <span class="operator">=</span> B ,B <span class="operator">=</span> ‘号码’）</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.personMemberID, <span class="operator">*</span> <span class="keyword">from</span> chineseresume a,personmember b <span class="keyword">where</span> a.personMemberID <span class="operator">=</span> b.referenceid <span class="keyword">and</span> a.personMemberID <span class="operator">=</span> ‘JCNPRH39681’ <span class="keyword">and</span> b.referenceid <span class="operator">=</span> ‘JCNPRH39681’ （A <span class="operator">=</span> B ,B <span class="operator">=</span> ‘号码’， A <span class="operator">=</span> ‘号码’）</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.personMemberID, <span class="operator">*</span> <span class="keyword">from</span> chineseresume a,personmember b <span class="keyword">where</span> b.referenceid <span class="operator">=</span> ‘JCNPRH39681’ <span class="keyword">and</span> a.personMemberID <span class="operator">=</span> ‘JCNPRH39681’ （B <span class="operator">=</span> ‘号码’， A <span class="operator">=</span> ‘号码’）</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量使用 <code>exists </code>代替 <code>select count(1)</code> 来判断是否存在记录，<code>count </code>函数只有在统计表中所有行数时使用，而且 <code>count(1)</code> 比 <code>count(*)</code> 更有效率。</p>
</li>
<li><p>尽量使用 <code>“&gt;=”</code>，不要使用<code> “&gt;”</code>。</p>
</li>
<li><p>索引的使用规范：索引的创建要与应用结合考虑，建议大的 <code>OLTP </code>表不要超过 <font color="orange">6</font> 个索引；尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过 <code>index </code> <code>index_name</code> 来强制指定索引；避免对大表查询时进行 <code>table scan</code>，必要时考虑新建索引；在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；要注意索引的维护，周期性重建索引，重新编译存储过程。</p>
</li>
<li><p>下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> record <span class="keyword">WHERE</span> <span class="built_in">substrINg</span>(card_no,<span class="number">1</span>,<span class="number">4</span>)<span class="operator">=</span>’<span class="number">5378</span>’ (<span class="number">13</span>秒)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> record <span class="keyword">WHERE</span> amount<span class="operator">/</span><span class="number">30</span><span class="operator">&lt;</span> <span class="number">1000</span> （<span class="number">11</span>秒）</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> record <span class="keyword">WHERE</span> <span class="keyword">convert</span>(<span class="type">char</span>(<span class="number">10</span>),<span class="type">date</span>,<span class="number">112</span>)<span class="operator">=</span>’<span class="number">19991201</span>’ （<span class="number">10</span>秒）</span><br><span class="line"></span><br><span class="line"># 分析：</span><br><span class="line"># <span class="keyword">WHERE</span>子句中对列的任何操作结果都是在<span class="keyword">SQL</span>运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引；如果这些结果在查询编译时就能得到，那么就可以被<span class="keyword">SQL</span>优化器优化，使用索引，避免表搜索，因此将<span class="keyword">SQL</span>重写成下面这样：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> record <span class="keyword">WHERE</span> card_no <span class="keyword">like</span> ‘<span class="number">5378</span><span class="operator">%</span>’ （<span class="operator">&lt;</span> <span class="number">1</span>秒）</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> record <span class="keyword">WHERE</span> amount<span class="operator">&lt;</span> <span class="number">1000</span><span class="operator">*</span><span class="number">30</span> （<span class="operator">&lt;</span> <span class="number">1</span>秒）</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> record <span class="keyword">WHERE</span> <span class="type">date</span><span class="operator">=</span> ‘<span class="number">1999</span><span class="operator">/</span><span class="number">12</span><span class="operator">/</span><span class="number">01</span>’ （<span class="operator">&lt;</span> <span class="number">1</span>秒）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>当有一批处理的插入或更新时，用<font color="orange">批量插入或批量更新</font>，绝不会一条条记录的去更新!</p>
</li>
<li><p>在所有的存储过程中，能够用 <code>SQL</code> 语句的，绝不会用<strong>循环</strong>去实现!</p>
<p>(例如：列出上个月的每一天，用 <code>connect by</code> 去递归查询一下，绝不会去用循环从上个月第一天到最后一天)</p>
</li>
<li><p>选择最有效率的表名顺序(只在基于规则的优化器中有效)：</p>
<p><code>oracle </code>的解析器按照从<font color="orange">右到左</font>的顺序处理 <code>FROM </code>子句中的表名，<code>FROM </code>子句中写在最后的表(基础表 <code>driving table</code>)将被最先处理，在 <code>FROM </code>子句中包含多个表的情况下,你必须<font color="yellow">选择记录条数最少的表作为基础表</font>。如果有3个以上的表连接查询, 那就需要选择<font color="yellow">交叉表(intersection table)</font>作为基础表, 交叉表是指那个被其他表所引用的表.</p>
</li>
<li><p>提高 <code>GROUP BY</code> 语句的效率, 可以通过将不需要的记录在 <code>GROUP BY </code>之前过滤掉.下面两个查询返回相同结果，但第二个明显就快了许多.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 低效:</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> JOB , <span class="built_in">AVG</span>(SAL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> JOB</span><br><span class="line"></span><br><span class="line"><span class="keyword">HAVING</span> JOB <span class="operator">=</span>’PRESIDENT’</span><br><span class="line"></span><br><span class="line"><span class="keyword">OR</span> JOB <span class="operator">=</span>’MANAGER’</span><br><span class="line"></span><br><span class="line"># 高效:</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> JOB , <span class="built_in">AVG</span>(SAL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> JOB <span class="operator">=</span>’PRESIDENT’</span><br><span class="line"></span><br><span class="line"><span class="keyword">OR</span> JOB <span class="operator">=</span>’MANAGER’</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> JOB</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sql</code> 语句用大写，因为 <code>oracle </code>总是先解析 <code>sql </code>语句，把小写的字母转换成大写的再执行。</p>
</li>
<li><p>别名的使用，别名是大型数据库的应用技巧，就是<font color="orange">表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。</font></p>
</li>
<li><p>避免<font color="yellow">死锁</font>，在你的 <font color="orange">存储过程和触发器中访问同一个表时总是以相同的顺序</font>;事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量;<font color="yellow">永远不要在事务中等待用户输入</font>。</p>
</li>
<li><p>避免使用临时表，除非却有需要，否则应<font color="cornflowerblue">尽量避免使用临时表</font>，相反，可以使用<code>表变量</code>代替;大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在 <code>TempDb</code> 数据库中，因此临时表上的操作需要<code>跨数据库通信</code>，速度自然慢。</p>
</li>
<li><p>最好不要使用触发器，触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程;如果能够使用<code>约束</code>实现的，尽量不要使用触发器;不要为不同的触发事件<code>(Insert，Update和Delete) </code>使用相同的触发器;不要在触发器中使用<font color="orange">事务型代码</font>。</p>
</li>
<li><p>索引创建规则：</p>
<ul>
<li>表的<code>主键</code>、<code>外键</code>必须有索引；</li>
<li>数据量超过<code>300万</code>的表应该有索引；</li>
<li>经常与其他表进行连接的表，在<code>连接字段</code>上应该建立索引；</li>
<li>经常出现在 <code>Where </code>子句中的字段，特别是大表的字段，应该建立索引；</li>
<li>索引应该建在<code>选择性高</code>的字段上；</li>
<li>索引应该建在<code>小字段</code>上，对于大的文本字段甚至超长字段，不要建索引；</li>
<li>复合索引的建立需要进行<code>仔细分析</code>，尽量考虑用<code>单字段索引</code>代替；</li>
<li>正确选择复合索引中的<code>主列字段</code>，一般是<code>选择性较好的字段</code>；</li>
<li>复合索引的几个字段是否经常同时以 <code>AND </code>方式出现在 <code>Where </code>子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；</li>
<li>如果复合索引中包含的字段经常单独出现在 <code>Where </code>子句中，则分解为多个单字段索引；</li>
<li>如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；</li>
<li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；</li>
<li><font color="orange">频繁进行数据操作的表，不要建立太多的索引</font>；</li>
<li><code>删除无用的索引</code>，避免对执行计划造成负面影响；</li>
<li>表上建立的每个索引都会增加<code>存储开销</code>，索引对于<font color="orange">插入、删除、更新操作也会增加处理上的开销</font>。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。</li>
<li><font color="orange">尽量不要对数据库中某个含有大量重复的值的字段建立索引</font>。</li>
</ul>
</li>
<li><p>mysql查询优化总结：使用<code>慢查询日志</code>去发现<code>慢查询</code>，使用<code>执行计划</code>去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。久而久之性能总会变化，避免在整个表上使用 <code>count(*)</code> ,它可能<code>锁</code>住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用 <code>GROUP BY</code> 而不是<code> DISTINCT</code>，在 <code>WHERE</code>, <code>GROUP BY</code> 和 <code>ORDER BY</code> 子句中使用有索引的列，保持索引简单,不在多个索引中包含同一个列，有时候 <code>MySQL </code>会使用错误的索引,对于这种情况使用 <code>USE INDEX</code>，检查使用 <code>SQL_MODE=STRICT </code>的问题，对于记录数小于5的索引字段，在 <code>UNION</code> 的时候使用 <code>LIMIT</code> 不是是用 <code>OR</code>。</p>
<p>为了 避免在更新前 <code>SELECT</code>，使用 <code>INSERT ON DUPLICATE KEY</code> 或者 <code>INSERT IGNORE</code> ,不要用 <code>UPDATE </code>去实现，不要使用 <code>MAX</code>,使用索引字段和 <code>ORDER BY </code>子句，<code>LIMIT M，N</code>实际上可以减缓查询在某些情况下，有节制地使用，在 <code>WHERE </code>子句中使用 <code>UNION </code>代替子查询，在重新启动的 <code>MySQL</code>，记得来温暖你的数据库，以确保您的数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销，基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加您的服务器上，使用<code>SHOW PROCESSLIST</code> 查看慢的和有问题的查询，在开发环境中产生的镜像数据中 测试的所有可疑的查询。</p>
</li>
<li><p><code>MySQL </code>备份过程:</p>
<p>从二级复制服务器上进行备份。在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致。彻底停止<code>MySQL</code>，从数据库文件进行备份。</p>
<p>如果使用 <code>MySQL dump</code> 进行备份，请同时备份二进制日志文件 – 确保复制没有中断。不要信任 <code>LVM</code> 快照，这很可能产生数据不一致，将来会给你带来麻烦。为了更容易进行单表恢复，以表为单位导出数据 – 如果数据是与其他表隔离的。</p>
<p>当使用 <code>mysqldump </code>时请使用 <code>–opt</code>。在备份之前检查和优化表。为了更快的进行导入，在导入时临时禁用外键约束。</p>
<p>为了更快的进行导入，在导入时临时禁用唯一性检测。在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长。</p>
<p>通过自动调度脚本监控复制实例的错误和延迟。定期执行备份。</p>
</li>
<li><p>查询缓冲<font color="orange">并不自动处理空格</font>，因此，在写SQL语句时，应<font color="orange">尽量减少空格的使用</font>，尤其是在SQL首和尾的空格(因为，查询缓冲并不自动截取首尾空格)。</p>
</li>
<li><p><code>member </code>用 <code>mid </code>做标准进行分表方便查询么？一般的业务需求中基本上都是以 <code>username</code> 为查询依据，正常应当是 <code>username</code> 做 <code>hash</code> 取模来分表吧。分表的话 <code>mysql </code>的<code>partition</code> 功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。</p>
</li>
<li><p>我们应该为数据库里的每张表都设置一个 <code>ID</code> 做为其主键，而且最好的是一个 <code>INT </code>型的（推荐使用 <code>UNSIGNED</code> ），并设置上自动增加的<code> AUTO_INCREMENT</code> 标志。</p>
</li>
<li><p>在所有的存储过程和触发器的开始处设置 <code>SET NOCOUNT ON</code> ，在结束时设置 <code>SET NOCOUNT OFF</code> 。无需在执行存储过程和触发器的每个语句后向客户端发送 <code>DONE_IN_PROC</code> 消息。</p>
</li>
<li><p><code>MySQL </code>查询可以<font color="orange">启用高速查询缓存</font>。这是提高数据库性能的有效 <code>Mysql </code>优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。</p>
</li>
<li><p><code>EXPLAIN SELECT</code> 查询用来跟踪查看效果</p>
<p>使用 <code>EXPLAIN </code>关键字可以让你知道 <code>MySQL </code>是如何处理你的 <code>SQL </code>语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。<code>EXPLAIN </code>的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。</p>
</li>
<li><p>当只要一行数据时使用 <code>LIMIT 1</code></p>
</li>
<li><p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去 <code>fetch </code>游标，或是你也许会去检查返回的记录数。在这种情况下，加上 <code>LIMIT 1</code> 可以增加性能。这样一样，<code>MySQL</code> 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p>
</li>
<li><p>选择表合适存储引擎：</p>
<p><code>myisam</code>: 应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。</p>
<p><code>Innodb</code>：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（<code>Innodb</code>有效地降低删除和更新导致的锁定）。对于支持事务的<code>InnoDB</code>类型的表来说，影响速度的主要原因是 <code>AUTOCOMMIT </code>默认设置是打开的，而且程序没有显式调用 <code>BEGIN </code>开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行 <code>sql </code>前调用 <code>begin</code>，多条 <code>sql</code> 形成一个事务（即使 <code>autocommit</code> 打开也可以），将大大提高性能。</p>
</li>
<li><p>优化表的数据类型,选择合适的数据类型：</p>
<p>原则：更小通常更好，简单就好，<font color="orange">所有字段都得有默认值,尽量避免null</font>。</p>
<p>例如：数据库表设计时候更小的占磁盘空间<font color="orange">尽可能使用更小的整数类型</font>.( <code>mediumint</code> 就比 <code>int</code> 更合适)</p>
<p>比如时间字段：<code>datetime</code> 和 <code>timestamp</code>, <code>datetime</code>占用8个字节，而 <code>timestamp</code> 占用4个字节，只用了一半，而 <code>timestamp</code> 表示的范围是1970—2037适合做<font color="yellow">更新时间</font></p>
<p><code>MySQL</code> 可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。</p>
<p>因此，在创建表的时候，为了获得更好的性能，我们可以将<code>表中字段的宽度设得尽可能小</code>。例如，</p>
<p>在定义邮政编码这个字段时，如果将其设置为<code> CHAR(255)</code> ,显然给数据库增加了不必要的空间，</p>
<p>甚至使用 <code>VARCHAR </code>这种类型也是多余的，因为 <code>CHAR(6)</code> 就可以很好的完成任务了。同样的，如果可以的话，</p>
<p>我们应该使用 <code>MEDIUMINT</code> 而不是 <code>BIGIN</code> 来定义整型字段。</p>
<p>应该尽量把字段设置为 <code>NOT NULL</code>，这样在将来执行查询的时候，数据库不用去比较 <code>NULL </code>值。</p>
<p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为 <code>ENUM </code>类型。因为在 <code>MySQL</code> 中，<code>ENUM</code> 类型被当作<code>数值型数据</code>来处理，</p>
<p>而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>
</li>
<li><p>字符串数据类型：<code>char</code>，<code>varchar</code>，<code>text</code>选择区别</p>
</li>
<li><p>任何对<font color="orange">列</font>的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要<font color="orange">尽可能将操作移至等号右边</font>。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://hqzqaq.github.io/2022/09/23/mysql-%E5%9F%BA%E7%A1%80/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/09/23/mysql-%E9%AB%98%E7%BA%A7/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            mysql 高级
          
        </div>
      </a>
    
    
      <a href="/2022/09/23/mongoDB/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">mongoDB</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> hqz
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="hqz的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/java/">java</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/machineLearning/">机器学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/webGIS/">webGIS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/bigData/">大数据</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/GIS/">GIS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/academic/">学术</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/other/">other</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>